---
title: "MECR KO Report"
author: "Anton_Zhelonkin"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    theme: united
---


```{r}
##############################
## Prepairing the environment
##############################

# Don`t show code in the report set up 
knitr::opts_chunk$set(echo = FALSE)

# cleaning sessionInfo
rm(list = ls())
# Reset graphical parameters
graphics.off()
# Reset options to default (optional)
options(default = TRUE)

#### Library preparation
# Install if necessary 
if (!requireNamespace("edgeR", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
        install.packages("BiocManager")
    }
    BiocManager::install("edgeR")
}

if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}

if (!requireNamespace("EnhancedVolcano", quietly = TRUE)) {
  BiocManager::install('EnhancedVolcano')
}


# attaching libraries
library(ggplot2)
library(edgeR)
library(EnhancedVolcano)
library(limma)
```


# 1. Data Preparation

Raw counts data were filtered using `edgeR`s function `filterByExpr` and normalized using standard `TMM` (trimmed mean of M values) method, which accounts for sequencing depth, RNA composition, and gene length, and is the standard recommended method in `edgeR`s vignette. For the exploratory visualisations read counts per million were calculated and log+1 transformed. 

```{r echo = FALSE, include = FALSE}
# Reading data
rawData_trimmed <- read.table('init_data/counts_matrix_trimmed.txt', 
                      header = TRUE, 
                      row.names = 1,
                      stringsAsFactors = FALSE)

# Assign sample names
colnames(rawData_trimmed) <- c('KO1', 'KO2', 'KO3', 'WT1', 'WT2', 'WT3')

# Strip daway metadata
# Check if there's any unwanted metadata row, e.g., 'Geneid', and remove it if necessary
# If the first row is metadata, you can drop it explicitly:
if ("Geneid" %in% rownames(rawData_trimmed)) {
  rawData_trimmed <- rawData_trimmed[-which(rownames(rawData_trimmed) == "Geneid"), ]
}

# Convert chr to int, preserving rownames - using [] to preserve row attributes
rawData_trimmed[] <- lapply(rawData_trimmed, as.integer)

# Check for any NA values (indicating conversion issues)
any_na <- any(is.na(rawData_trimmed))
# If any NA values are found, investigate
if (any_na) {
  print("Warning: Some non-numeric values were converted to NA. Please check your data.")
} else {
  print("No NAs introduced during values conversion")
}

# Create DGEList object
rawDGE_t <- DGEList(rawData_trimmed)

# Create a grouping factor 
group <- factor(
  c(
    rep("KO", 3),
    rep("WT", 3)
  )
)

# Add grouping to the DGEList object
rawDGE_t$samples$group <- group

# filtering genes by expression, getting rid of low count genes
keep <- filterByExpr(rawDGE_t)
rawDGE_t <- rawDGE_t[keep, , keep.lib.sizes=FALSE] # update lib sizes

# data normalization
rawDGE_t <- normLibSizes(rawDGE_t, 
                              method = "TMM")

# Releveling the factor to set WT as the reference level for further modelling
rawDGE_t$samples$group<- relevel(rawDGE_t$samples$group, ref = "WT")

# calculating logCPM
logCPM <- cpm(rawDGE_t, log = TRUE, prior.count = 1)
```


# 2. Exploratory analysis

## PCA

**PCA Data Preparation for Plotting**: : The first two principal components (PC1 and PC2) were extracted from the PCA results and combined with metadata (group/condition) and sample names.

```{r}
# Calculate PCA
pca <- prcomp(t(logCPM))

# Prepare PCA for plotting 
pca_data <- data.frame(
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  condition = rawDGE_t$samples$group,
  sample_names = colnames(logCPM)  # Assuming colnames are the sample names
)
```

**Variance Explained by Principal Components**: The proportion of variance explained by each principal component was calculated as a percentage. This provides context for interpreting the PCA plot by quantifying how much of the total variance is captured by PC1 and PC2.

```{r}
# Percent of PCA variance
percentVar <- pca$sdev^2 / sum(pca$sdev^2) * 100
```

**PCA Plot:** The PCA plot visualizes the first two principal components, with points representing individual samples. Points were colored and shaped according to the experimental condition (i.e., group).  

```{r}
require(ggplot2)
require(ggalt)

# Custom minimal theme 
# Custom theme with minimal style and grid lines
custom_minimal_theme_with_grid <- function() {
  theme_minimal() +
    theme(
      # Customize the axes
      axis.line = element_line(color = "black"),
      axis.ticks = element_line(color = "black"),
      axis.title.x = element_text(size = 12, face = "bold"),
      axis.title.y = element_text(size = 12, face = "bold"),
      axis.text.x = element_text(size = 10),
      axis.text.y = element_text(size = 10),
      # Major and minor grid lines with transparency
      panel.grid.major = element_line(color = "grey90", size = 0.5),  # Major grid lines (lighter)
      panel.grid.minor = element_line(color = "grey95", size = 0.25)   # Minor grid lines (even lighter)
    )
}

# Assuming you've already calculated the PCA and created pca_data
# Add batch information to pca_data
pca_data$group <- rawDGE_t$samples$group

# PCA plot with sample names
ggplot(pca_data, aes(x = PC1, y = PC2, color = condition, shape = condition)) +
  geom_point(size = 3) +
  geom_text(aes(label = sample_names), vjust = -1, hjust = 1, 
            size = 3,
            show.legend = FALSE) +  # Add sample names
  labs(color = "Condition", shape = "Condition") +
  xlab(paste0("PC1: ", round(percentVar[1], 1), "% variance")) +
  ylab(paste0("PC2: ", round(percentVar[2], 1), "% variance")) +
  ggtitle("Principal Component Analysis on the logCPM") +
  custom_minimal_theme_with_grid() +
  xlim(-90,110) +
  ylim(-80,80) +
  theme(
      legend.position = "inside",
      legend.position.inside = c(0.85,0.9),  # Use legend.position.inside for inside positioning
      legend.justification = c(0, 1),  # Align legend to top-left inside plot
      legend.box.background = element_rect(color = "black", linewidth = 0.5),  # Use linewidth instead of size
      legend.box.margin = margin(2, 2, 2, 2),  # Optional: Adjust margin around legend box
      plot.title = element_text(hjust=0.2, vjust=0.2, margin = margin(b=10)),
      plot.margin = margin(20,20,20,20)
  )
```

## Scree plot - Proportion of Variance explained by PCA

The major % of variance is explained by the first component. The first PCA has obivously captured the nice delineation between the WT and KO samples. 

```{r}
# Scree plot data preparation
scree_data <- data.frame(PC = 1:length(pca$sdev), 
                         var_explained = percentVar)

ggplot(scree_data, aes(x = PC, y = var_explained)) +
  geom_bar(stat = "identity") +
  xlab("Principal Component") +
  ylab("Proportion of Variance Explained") +
  ggtitle("Scree Plot")
```


## Samples heatmap

*Sample Correlation Matrix and Heatmap:* A sample correlation matrix was computed using Pearson correlation, quantifying the similarity in gene expression profiles between pairs of samples based on the logCPM values. This matrix reflects how closely samples relate to each other in terms of their overall expression patterns.  A heatmap of the sample correlation matrix was generated using the pheatmap() function. The heatmap displayed correlation values between samples, with annotations for experimental group and temperature shown for each sample.  

```{r echo = FALSE}
require(pheatmap)

# Sample correlation calculation
sample_cor <- cor(logCPM, method = "pearson")

# Correlation heatmap
pheatmap(sample_cor, 
         main = "Sample Correlation Heatmap",
         method = "ward.D")
```


# 3. Statistical Modelling 

The design matrix for initial modelling has been set up using the formula: 

> Desing formula
  ```
  DEGs ~ group
  ```

...which basically means. Variable on the left-hand side of a tilde (~) is called the "dependent variable", while the variables on the right-hand side are called the "independent variables" and are joined by plus signs +. Variables joined by * sign, are interactions terms, i.e. we\`re interested in how the intereaction between variables influences the dependant variable. 

*Weighted limma-voom Transformation* 
To account for both sample quality and variability in read counts across samples, we applied the voomWithQualityWeights function from the limma package. This method incorporates sample-specific weights during normalization, ensuring that poor-quality samples have reduced influence on the differential expression analysis.  

```{r echo = TRUE}
# Releveling the group factor variable
rawDGE_t$samples$group <- relevel(rawDGE_t$samples$group, ref = "WT")

# Setting the desing 
design <- model.matrix(~group, data = rawDGE_t$samples)
colnames(design) <- c("WT", "MecrKO")

## EdgeR`s voomLmFit does all this under the hood: logCPM, limmaWeighted, corfit, lmFit
fit <- edgeR::voomLmFit(counts = rawDGE_t,
                        design = design,
                        sample.weights = TRUE
                        )
# edgeR::voomLmFit performs limma`s voomWithQualityWeights with duplicateCorrelation
# If block is specified voom weights and intra-block correlation are each estimated twice

# Set the contrasts 
contrasts <- makeContrasts(
  # Overall treatment effect (across both batches)
  KOvsWT = MecrKO - WT,
  levels = design
)

# Compute contrasts from linear model
fit <- contrasts.fit(fit, contrasts)

# Compute moderated t-statistics
fit <- eBayes(fit)

# Extract contrast coefficients
## Overall treatment effect 
DE_KOvsWT <- topTable(fit, 
         coef="KOvsWT", 
         sort.by = "t",
         n=Inf)

str(DE_KOvsWT)
```
 
```{r}
require(dplyr)

# Sort the data to get top 5 most negative and top 5 most positive DE genes
top_negative <- results_df %>%
  arrange(logFC) %>%
  slice_head(n = 5) %>%
  pull(genes)  # Get the gene names

top_positive <- results_df %>%
  arrange(desc(logFC)) %>%
  slice_head(n = 5) %>%
  pull(genes)  # Get the gene names

# Combine the top negative and positive DE genes for labeling
top_genes <- c(top_negative, top_positive)

# Plot using EnhancedVolcano with the selected genes
p <- EnhancedVolcano(results_df,
    lab = results_df$genes,
    x = 'logFC',
    y = 'adj.P.Val',
    selectLab = top_genes,  # Only label the top 5 negative and positive DE genes
    xlab = bquote(~Log[2]~ 'fold change'),
    pCutoff = 0.05,
    FCcutoff = 4.0,
    pointSize = 2.0,
    labSize = 6.0,
    labCol = 'black',
    labFace = 'bold',
    boxedLabels = TRUE,
    colAlpha = 4/5,
    legendPosition = 'right',
    legendLabSize = 14,
    legendIconSize = 4.0,
    drawConnectors = TRUE,
    widthConnectors = 1.0,
    colConnectors = 'black',
    title = 'Volcano Plot',
    subtitle = 'Differentially Expressed Genes in MECR-KO against WT',
    caption = 'Thresholds: Log2FC > 4, adjusted P value < 0.05')

# Save the plot
ggsave(
  filename = "imgs/DE_all_volcano.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)

# Print the plot
print(p)
```



# 4. Gene Set Enrichment Analysis

Gene set enrichment analysis was performed using the `clusterProfiler` package.
We tested pathway enrichment against `msigdbr` genesets database. 
* Hallmark Pathways
* ImmuneSigDB subset of C7 - Gene sets representing chemical and genetic perturbations of the immune system generated by manual curation of published studies in human and mouse immunology
* REACTOME
* GO
* MF: subset of GO - Gene sets derived from the GO Molecular Function ontology. 
The ranked gene list for the GSEA was ranked based on the moderated t-statistic. 

We`ll be specifically focusing on the target pathways outlined below: 
* TCR signaling 
* Myc pathways 
* JAK/STAT pathway
* Pi3K pathway 
* mTOR pathway 
* NFAT


## 4.1 MSigDB Hallmark Pathways enrichment analysis

```{r}
##########
# Define functions
##########


###############
### Custom GSEA plot function
###############

library(ggplot2)
library(dplyr)
library(stringr)
library(scales)

# Define custom dotplot function for GSEA objects with text processing and sorting options
custom_dotplot <- function(gsea_obj, showCategory = 10, font.size = 10, title = "GSEA Dotplot",
                           replace_ = TRUE, capitalize_1 = TRUE, capitalize_all = FALSE, 
                           filterBy = "qvalue",
                           sortBy = "GeneRatio",
                           q_cut = 0.05,
                           min.dotSize = 2) {
  
  # Extract the result data frame from the GSEA object
  gsea_data <- as.data.frame(gsea_obj@result)
  
  # Calculate the gene count from 'core_enrichment' by counting '/' and adding 1 (number of genes)
  gene_count <- gsea_data %>%
    group_by(ID) %>%
    summarise(count = sum(str_count(core_enrichment, "/")) + 1)
  
  # Merge gene counts with the original GSEA result and calculate GeneRatio
  gsea_data <- left_join(gsea_data, gene_count, by = "ID") %>%
    mutate(GeneRatio = count / setSize)
  
  # Modify Description field based on function arguments
  if (replace_) {
    gsea_data$Description <- gsea_data$Description %>% 
      str_replace_all("_", " ")   # Replace "_" with " " if 'replace' is TRUE
  }
  
  if (capitalize_1) {
    gsea_data$Description <- gsea_data$Description %>%
      str_to_sentence()           # Capitalize only the first word if 'capitalize_1' is TRUE
  }
  
  if (capitalize_all) {
    gsea_data$Description <- gsea_data$Description %>%
      str_to_title()              # Capitalize all words if 'capitalize_all' is TRUE
  }
  
  # Filter for significant pathways (qvalue < 0.01)
  gsea_data_filtered <- gsea_data %>%
    filter(qvalue < q_cut) %>%
    mutate(NES_sign = ifelse(NES > 0, "Positive NES", "Negative NES"))
  
  # Filter logic based on 'filterBy' argument
  if (filterBy == "qvalue") {
    # Sort by qvalue (default behavior)
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(qvalue) %>%           # Sort by qvalue (ascending)
      head(showCategory)
  } else if (filterBy == "NES") {
    # Sort by absolute NES value (strongest enrichment)
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(desc(abs(NES))) %>%    # Sort by absolute NES (descending)
      head(showCategory)
  } else if (filterBy == "NES_positive") {
    # Filter and sort by positive NES values only
    gsea_data_filtered <- gsea_data_filtered %>%
      filter(NES > 0) %>%           # Filter positive NES
      arrange(desc(NES)) %>%        # Sort by NES (descending)
      head(showCategory)
  } else if (filterBy == "NES_negative") {
    # Filter and sort by negative NES values only
    gsea_data_filtered <- gsea_data_filtered %>%
      filter(NES < 0) %>%           # Filter negative NES
      arrange(NES) %>%              # Sort by NES (ascending, more negative first)
      head(showCategory)
  }

 # Sort the filtered data based on the sortBy parameter
  if (sortBy == "GeneRatio") {
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(desc(GeneRatio))
  } else if (sortBy == "qvalue") {
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(qvalue)
  } else {
    warning("Invalid sortBy parameter. Defaulting to GeneRatio.")
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(desc(GeneRatio))
  }

  # Take the top showCategory entries after sorting
  gsea_data_filtered <- gsea_data_filtered %>%
    head(showCategory)

  # Create custom dotplot using ggplot2
  ggplot(gsea_data_filtered, aes(x = GeneRatio, y = reorder(Description, !!sym(sortBy)))) +
    geom_point(aes(size = -log10(qvalue), color = NES_sign)) +
    scale_color_manual(values = c("Positive NES" = "orange", "Negative NES" = "skyblue")) +
    
    # Use scale_size_continuous to set visual size limits for the dots
    scale_size_continuous(range = c(min.dotSize, 10),
                          limits = c(min(-log10(gsea_data_filtered$qvalue)), 
                                     max(-log10(gsea_data_filtered$qvalue))),
                          name = "-log10(qvalue)") +
    labs(
      title = title,
      x = "GeneRatio",
      y = NULL,
      color = "NES",
      size = "-log10(qvalue)"
    ) +
    
    custom_minimal_theme_with_grid() +
    theme(
      panel.background = element_rect(fill = "white", color = NA),  # White background with black border
      plot.background = element_rect(fill = "white", color = NA),  # White plot background with no border
      axis.text.y = element_text(size = font.size, hjust = 1),
      plot.title = element_text(hjust = 0.5, size = font.size + 2),
      axis.text.x = element_text(size = font.size),
      legend.position = "right"
    )
}
```

Here is the list of the enriched Hallmark Pathways.

```{r echo = FALSE}
library(org.Mm.eg.db)  # Mouse-specific annotation
library(msigdbr) # MSigDB
library(clusterProfiler)


# Prepare the ranked gene list (from limma results)
# Rank by logFC or another relevant statistic

# Rank by t.value
ranked_genes <- DE_KOvsWT$t
names(ranked_genes) <- rownames(DE_KOvsWT) # Ensure Gene column contains gene symbols

# Sort genes by t (or other ranking criterion), just in case it hasn`t been sorted already
ranked_genes <- sort(ranked_genes, decreasing = TRUE)

# Retrieve Mouse Hallmark gene sets from MSigDB
msigdb_H <- msigdbr(species = "Mus musculus", 
                    category = "H")  # "H" is for hallmark gene sets

# Perform GSEA using clusterProfiler
GSE_H <- GSEA(ranked_genes, 
                     TERM2GENE = msigdb_H[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0,
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```

### All Hallmark pathways

```{r}
p <- custom_dotplot(gsea_obj = GSE_H, 
               showCategory = 50, 
               font.size = 10, 
               title = "Top MECR-KO GSEA enriched hallmark pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_H)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/GSEA_Hallmark_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


### Top 20 Hallmark Pathways

```{r}
p <- custom_dotplot(gsea_obj = GSE_H, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA enriched hallmark pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/GSEA_Hallmark_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Running score plots 
```{r}
library(enrichplot)
```


#### Top 5 Pathways running score plot 
```{r}
p <- gseaplot2(GSE_H, geneSetID = 1:5)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_top5.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

#### Myc running score plot 
```{r}
title = "Myc targets V1 hallmark pathway"

p <- gseaplot(GSE_H, 
              geneSetID = 1, 
              by = "runningScore", 
              title = title)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_Myc.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 5,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

#### Top 12 running score plot 
```{r}
# Define the custom function to plot GSEA results
plot_gsea_results <- function(gsea_results, n_plots = 12) {
  # Load required libraries
  library(cowplot)
  library(ggplot2)

  # Create an empty list to store the plots
  plot_list <- list()

  # Loop through geneSetID 1 to n_plots and generate the plots
  for (i in 1:n_plots) {
    # Replace underscores with spaces in the title
    plot_title <- gsub("_", " ", gsea_results$Description[i])
    
    # Generate each plot using gseaplot
    p <- gseaplot(gsea_results, 
                  geneSetID = i, 
                  by = "runningScore", 
                  title = plot_title)  # Use the modified title with spaces
    
    # Apply theme modifications: smaller x and y axis titles and bold plot title
    p <- p + theme(
      axis.title.x = element_text(size = 10),  # Set smaller x-axis title size
      axis.title.y = element_text(size = 10),  # Set smaller y-axis title size
      plot.title = element_text(face = "bold", size = 12, hjust = 0.5)  # Bold and center plot title
    )
    
    # Remove y-axis text but keep individual ticks and breaks for plots not in the first column
    if (i %% 3 != 1) {  # If the plot is not in the first column
      p <- p + theme(axis.title.y = element_blank())  # Only remove the y-axis title, not the ticks or labels
    }
    
    # Remove x-axis text only for plots that are not in the last row
    # Calculate how many rows there are and find which plots are in the last row
    rows <- ceiling(n_plots / 3)  # Number of rows
    last_row_plots <- (rows - 1) * 3 + 1:n_plots %% 3
    
    if (i <= (rows - 1) * 3) {  # If the plot is not in the last row
      p <- p + theme(axis.title.x = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank())
    }
    
    # Add the plot to the list
    plot_list[[i]] <- p
  }

  # Combine all the plots into a 3-column grid using cowplot
  combined_plot <- plot_grid(plotlist = plot_list, ncol = 3)


  # Optionally, return the plot object
  return(combined_plot)
}
```

```{r}
# Display the top 12 pathways:
p12 <- plot_gsea_results(GSE_H, n_plots = 12)
p12
# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_top12.png",  # Specify the file path and name
  plot = p12,  # The plot to save
  width = 14, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

#### Top 24 running score plot 

```{r}
# Display top 24 pathways
p24 <- plot_gsea_results(GSE_H, n_plots = 24)
p24

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_top24.png",  # Specify the file path and name
  plot = p24,  # The plot to save
  width = 14, height = 18,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


### Volcano Plots
```{r}
##################
### Combined Volcano Plot Function with Multiple Styles
##################

library(ggplot2)
library(dplyr)
library(stringr)
library(ggrepel)

# Custom theme with minimal style and grid (used in multiple styles)
custom_minimal_theme_with_grid <- function() {
  theme_minimal(base_size = 14) +
    theme(
      panel.background = element_rect(fill = "white", color = NA), 
      plot.background = element_rect(fill = "white", color = NA),
      panel.grid.major = element_line(color = "grey80", size = 0.5),
      panel.grid.minor = element_line(color = "grey90", size = 0.25),
      axis.line = element_line(color = "black"),
      axis.ticks = element_line(color = "black"),
      axis.title.x = element_text(size = 14, face = "bold"),
      axis.title.y = element_text(size = 14, face = "bold"),
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12)
    )
}

# Main function to generate the volcano plot with different styles
analyze_pathway_volcano <- function(pathway_name, gsea_results, de_results, 
                                    p_cutoff = 0.05, fc_cutoff = 2.0, 
                                    label_method = "default", max_overlaps = 100, style = 'clean', 
                                    x_breaks = 1) {  # Add x_breaks parameter
  # Step 1: Extract the relevant genes for the specified pathway
  message("Extracting genes for the pathway: ", pathway_name)
  pathway_genes <- as.data.frame(gsea_results) %>%
    filter(Description == pathway_name) %>%
    pull(core_enrichment) %>% 
    str_split("/", simplify = TRUE) %>% 
    as.vector()

  # Step 2: Prepare DE results and identify pathway genes
  message("Preparing DE results...")
  de_results <- de_results %>%
    mutate(
      in_pathway = rownames(.) %in% pathway_genes,
      significant_fc = abs(logFC) > fc_cutoff,
      significant_p = adj.P.Val < p_cutoff,
      highlight = significant_fc & significant_p
    ) %>%
    # Add a color column based on the condition
    mutate(
      color = case_when(
        highlight ~ "p-value & Log2FC",   # Both significant fold change and p-value
        significant_fc ~ "Log2FC",        # Significant fold change only
        significant_p ~ "p-value",        # Significant p-value only
        TRUE ~ "NS"                       # Not significant
      )
    )
  
  # Determine labeling data based on method
  label_data <- switch(
    label_method,
    "default" = de_results %>% filter(in_pathway & highlight),  # Only label pathway genes with both p-value & Log2FC significant
    "fc" = de_results %>% filter(in_pathway & abs(logFC) > fc_cutoff),  # Label pathway genes crossing fold change threshold
    "p" = de_results %>% filter(in_pathway & adj.P.Val < p_cutoff),  # Label pathway genes crossing p-value threshold
    "all" = de_results %>% filter(in_pathway & (abs(logFC) > fc_cutoff | adj.P.Val < p_cutoff)),  # Label all significant pathway genes (either p-value or fold change)
    stop("Invalid label_method. Please use 'default', 'fc', 'p', or 'all'.")
  )

  # Determine the x-axis limits based on the user-defined x_breaks
  x_min <- floor(min(de_results$logFC) / x_breaks) * x_breaks  # Start from nearest multiple <= min(logFC)
  x_max <- ceiling(max(de_results$logFC) / x_breaks) * x_breaks  # End at nearest multiple >= max(logFC)

  # Define base plot
  base_plot <- ggplot(de_results, aes(x = logFC, y = -log10(adj.P.Val))) +
    geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed") +
    geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed") +
    labs(
      title = paste("Volcano Plot -", pathway_name),
      subtitle = paste("p-value cutoff:", p_cutoff, "| FC cutoff:", fc_cutoff),
      x = "Log2 Fold Change",
      y = "-Log10(Adj. P-value)"
    ) +
    # Set x-axis breaks based on user-defined x_breaks, ensuring alignment with the breaks pattern
    scale_x_continuous(breaks = seq(x_min, x_max, by = x_breaks), limits = c(x_min, x_max))

  # Choose plot style based on user input
  plot <- switch(
    style,
    'clean' = plot_style_clean(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    'claude' = plot_style_claude(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    'gpt' = plot_style_gpt(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    stop("Invalid style. Please use 'clean', 'claude', or 'gpt'.")
  )
  
  return(plot)
}

# Style 1: Clean style (original first style)
plot_style_clean <- function(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps) {
  # Define the colors for each condition
  colors <- c(
    "NS" = "#999999",               # Not significant
    "p-value & Log2FC" = "#E69F00", # Both p-value and Log2FC significant
    "p-value" = "#56B4E9"           # Only p-value significant
  )
  
  # Filter for pathway-specific data with different highlight criteria
  pathway_data <- de_results %>% filter(in_pathway)
  
  # Base plot with grey points for non-pathway genes
  plot <- base_plot +
    # Non-pathway genes in grey
    geom_point(data = de_results %>% filter(!in_pathway), 
               aes(color = "NS", alpha = 0.3), size = 1) +
    
    # Pathway genes: highlight based on p-value and fold change significance
    geom_point(data = pathway_data %>% filter(highlight), 
               aes(color = "p-value & Log2FC", alpha = 0.7), size = 1.5) +
    
    # Pathway genes: highlight based only on p-value significance
    geom_point(data = pathway_data %>% filter(!highlight & significant_p), 
               aes(color = "p-value", alpha = 0.7), size = 1.5) +
    
    # Set color scale manually and remove legend
    scale_color_manual(values = colors) +
    
    # Apply the custom minimal theme (assuming you have this function defined)
    custom_minimal_theme_with_grid() +
    theme(legend.position = "none")  # Remove the legend entirely
  
  # If there are genes to label, apply label repelling
  if (nrow(label_data) > 0) {
    plot <- plot + geom_label_repel(
      data = label_data,
      aes(label = rownames(label_data)),
      box.padding = 0.5,
      point.padding = 0.5,
      force = 5,
      segment.color = 'grey50',
      max.overlaps = max_overlaps
    )
  }
  
  return(plot)
}


# Style 2: Claude style (second version with enhanced volcano-style legend)
plot_style_claude <- function(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps) {
  colors <- c(
    "NS" = "#999999", "p-value" = "#56B4E9", "Log2FC" = "#0072B2", "p-value & Log2FC" = "#E69F00"
  )
  
  plot <- base_plot +
    geom_point(data = de_results %>% filter(!in_pathway), 
               color = "#CCCCCC", alpha = 0.3, size = 0.6) +
    geom_point(data = de_results %>% filter(in_pathway), 
               aes(color = color), alpha = 0.7, size = 1.5) +
    scale_color_manual(values = colors, 
                       name = "Significance",
                       labels = c("NS" = "NS", "p-value" = "p-value",
                                  "Log2FC" = "Log2FC", "p-value & Log2FC" = "p-value & Log2FC")) +
    custom_minimal_theme_with_grid() +
    theme(
      panel.background = element_rect(fill = "white", color = "black"),
      plot.background = element_rect(fill = "white", color = NA),
      legend.position = c(0.95, 0.95),
      legend.justification = c("right", "top"),
      legend.background = element_rect(fill = "white", color = "black")
    )
  
  if (nrow(label_data) > 0) {
    plot <- plot + geom_label_repel(
      data = label_data,
      aes(label = rownames(label_data)),
      box.padding = 0.5,
      point.padding = 0.5,
      force = 5,
      segment.color = 'grey50',
      max.overlaps = max_overlaps
    )
  }
  
  return(plot)
}

# Style 3: GPT style (third version with no alpha in legend)
plot_style_gpt <- function(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps) {
  colors <- c("NS" = "#999999", "Log2FC" = "#0072B2", "p-value" = "#56B4E9", "p-value & Log2FC" = "#E69F00")
  
  plot <- base_plot +
    geom_point(data = de_results %>% filter(!in_pathway), 
               aes(color = color, alpha = 0.2), size = 0.6) +
    geom_point(data = de_results %>% filter(in_pathway), 
               aes(color = color, alpha = 0.7), size = 1.5) +
    scale_color_manual(values = colors) +
    custom_minimal_theme_with_grid()+
    theme(legend.position = c(0.9, 0.9)) +
    guides(
      color = guide_legend(title = "Gene Status", override.aes = list(alpha = 1, size = 4)),
      alpha = "none"  # Remove alpha from legend
    )
  
  if (nrow(label_data) > 0) {
    plot <- plot + geom_label_repel(
      data = label_data,
      aes(label = rownames(label_data)),
      box.padding = 0.5,
      point.padding = 0.5,
      force = 5,
      segment.color = 'grey50',
      max.overlaps = max_overlaps
    )
  }
  
  return(plot)
}
```



## 4.2 MSigDB C2 Canonical Pathways (CP) gene sets enrichment analysis

```{r echo = FALSE}
library(org.Mm.eg.db)  # Mouse-specific annotation
library(msigdbr) # MSigDB
library(clusterProfiler)

# Prepare the ranked gene list (from limma results)
# Rank by logFC or another relevant statistic


# Retrieve C2 gene sets from MSigDB
msigdb_C2CP <- msigdbr(species = "Mus musculus", 
                     category = "C2",
                     subcategory = "CP")

# Perform GSEA using clusterProfiler
GSE_C2CP <- GSEA(ranked_genes, 
                     TERM2GENE = msigdb_C2CP[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0, # p value is not 
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```

### All C2CP Pathways
```{r}
p <- custom_dotplot(gsea_obj = GSE_C2CP, 
               showCategory = 100, 
               font.size = 10, 
               title = "MECR-KO GSEA C2 curated pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_C2CP)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold-0.01, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/GSEA_C2CP_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Top 20 C2CP Pathways

```{r}
p <- custom_dotplot(gsea_obj = GSE_C2CP, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA C2 curated pathways pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/GSEA_C2CP_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Running score plots 
```{r}
library(enrichplot)
```


#### Top 5 Pathways running score plot 
```{r}
p <- gseaplot2(GSE_C2CP, geneSetID = 1:5)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/RunningScore_top5.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

#### Top 12 running score plot 

```{r}
# Display the top 12 pathways:
p12 <- plot_gsea_results(GSE_C2CP, n_plots = 12)
p12
# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/RunningScore_top12.png",  # Specify the file path and name
  plot = p12,  # The plot to save
  width = 14, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


#### Top 24 running score plot 

```{r}
# Display top 24 pathways
p24 <- plot_gsea_results(GSE_C2CP, n_plots = 24)
p24

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/RunningScore_top24.png",  # Specify the file path and name
  plot = p24,  # The plot to save
  width = 14, height = 18,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


## 4.3 KEGG pathways enrichment analysis

Gene names converted from SYMBOL to ENTREZID. 0.02% of input gene IDs failed to map.

```{r echo = FALSE}
library(clusterProfiler)

#search_kegg_organism('mmu', by='kegg_code')

#### Gene KeyType conversion

# 1. Loading the ranked gene list, by t
ranked_genes <- DE_KOvsWT$t
names(ranked_genes) <- rownames(DE_KOvsWT)  # Ensure the 'Gene' column contains symbols
# 1.2. Sort the vector to be decreasing
ranked_genes <- sort(ranked_genes, decreasing = TRUE)

# 2. Convert gene symbols to Entrez IDs (for human genes, replace `org.Hs.eg.db` as necessary)
ids <- bitr(names(ranked_genes), 
            fromType = "SYMBOL", 
            toType = "ENTREZID", 
            OrgDb = org.Mm.eg.db)

# 3. Remove duplicates (keep unique Entrez IDs)
dedup_ids <- ids[!duplicated(ids$ENTREZID),]

# 4. Match and filter gene list to include only the mapped genes
ranked_genes_mapped <- ranked_genes[names(ranked_genes) %in% dedup_ids$SYMBOL]
names(ranked_genes_mapped) <- dedup_ids$ENTREZID[match(names(ranked_genes_mapped), dedup_ids$SYMBOL)]

# 5. Sort the vector to be decreasing
ranked_genes_mapped <- sort(ranked_genes_mapped, decreasing = TRUE)
```

```{r echo = FALSE}
# Retrieve C2 gene sets from MSigDB
msigdb_KEGG <- msigdbr(species = "Mus musculus", 
                     category = "C2",
                     subcategory = "KEGG")

# Perform GSEA using clusterProfiler
GSE_msigKEGG <- GSEA(ranked_genes, 
                     TERM2GENE = msigdb_KEGG[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0, # p value is not 
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```

### All KEGG Pathways
```{r}
p <- custom_dotplot(gsea_obj = GSE_msigKEGG, 
               showCategory = 100, 
               font.size = 10, 
               title = "MECR-KO GSEA C2 curated pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_msigKEGG)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/GSEA_KEGG_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 14,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Top 20 KEGG Pathways

```{r}
p <- custom_dotplot(gsea_obj = GSE_msigKEGG, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA KEGG pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/GSEA_KEGG_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

So far as we are not interested in particular disease related pathways or cancer types, while KEGG is abandunt in those, I have tried to manually filter pathways, that contain keywords, such as `cancer`, `disease`, `leukemia`,`carcinoma`, `depression`, `infection`, and other *`oma`s (like melanoma, carcinoma etc.)

```{r echo = FALSE}
library(dplyr)
library(stringr)

# List of disease-related keywords to filter out
disease_keywords <- c("cancer", "disease", "leukemia", 
                      "carcinoma", "depression", "infection",
                      "lupus")

# Filter out pathways with disease-related keywords or ending in "*oma"
filtered_KEGG <- msigdb_KEGG %>%
  mutate(gs_name_lower = str_to_lower(gs_name),      # Convert to lowercase for case-insensitive matching
         gs_name_clean = str_replace_all(gs_name_lower, "_", " ")) %>%   # Replace "_" with space
  filter(
    !str_detect(gs_name_clean, paste(disease_keywords, collapse = "|")) &  # Exclude if contains any of the disease keywords
    !str_detect(str_extract(gs_name_clean, "\\w+$"), "oma$")               # Exclude if the last word ends with "oma"
  )

# Drop the temporary columns used for filtering
filtered_KEGG <- filtered_KEGG %>%
  select(-gs_name_lower, -gs_name_clean)
```


```{r echo = FALSE}
# Perform GSEA using clusterProfiler
GSE_msigKEGG_no_disease <- GSEA(ranked_genes, 
                     TERM2GENE = filtered_KEGG[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0, # p value is not 
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```

### All KEGG (no disease) Pathways
```{r}
p <- custom_dotplot(gsea_obj = GSE_msigKEGG_no_disease, 
               showCategory = 100, 
               font.size = 10, 
               title = "MECR-KO GSEA KEGG pathways (no disease), qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_msigKEGG_no_disease)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/GSEA_KEGG_no_disease_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 14,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Top 20 KEGG (no disese) Pathways

```{r}
p <- custom_dotplot(gsea_obj = GSE_msigKEGG_no_disease, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA KEGG (no disease) pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/GSEA_KEGG_no_disease_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Running score plots 

#### Top 5 Pathways running score plot 
```{r}
p <- gseaplot2(GSE_msigKEGG_no_disease, geneSetID = 1:5)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/RunningScore_top5.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

#### Top 12 running score plot 

```{r}
# Display the top 12 pathways:
p12 <- plot_gsea_results(GSE_msigKEGG_no_disease, n_plots = 12)
p12
# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/RunningScore_top12.png",  # Specify the file path and name
  plot = p12,  # The plot to save
  width = 14, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


#### Top 24 running score plot 

```{r}
# Display top 24 pathways
p24 <- plot_gsea_results(GSE_msigKEGG_no_disease, n_plots = 24)
p24

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/RunningScore_top24.png",  # Specify the file path and name
  plot = p24,  # The plot to save
  width = 14, height = 18,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Volcano Plots

#### Antigen Processing & Presentation
```{r}
p <- analyze_pathway_volcano(
  pathway_name = "KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "all",  # or "fc"
  max_overlaps = 20, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/KEGG/AG_presentation.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


#### TCR signaling 

```{r}
p <- analyze_pathway_volcano(
  pathway_name = "KEGG_T_CELL_RECEPTOR_SIGNALING_PATHWAY",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "all",  # or "fc"
  max_overlaps = 25, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/KEGG/TCR_signaling.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```



## 4.n IMMUNESIGDB Pathways enrichment analysis

Here is the list of the enriched Hallmark Pathways.

ImmuneSigDB subset of C7

```{r echo = FALSE}
library(org.Mm.eg.db)  # Mouse-specific annotation
library(msigdbr) # MSigDB
library(clusterProfiler)


# Prepare the ranked gene list (from limma results)
# Rank by logFC or another relevant statistic

# Rank by t.value
ranked_genes <- DE_KOvsWT$t
names(ranked_genes) <- rownames(DE_KOvsWT) # Ensure Gene column contains gene symbols

# Sort genes by t (or other ranking criterion), just in case it hasn`t been sorted already
ranked_genes <- sort(ranked_genes, decreasing = TRUE)

# Retrieve Mouse C5 gene sets from MSigDB
msigdb_C7 <- msigdbr(species = "Mus musculus", category = "C5")  # "C7" 

# Filter for IMMUNESIGDB gene sets
immunesigdb_C7 <- msigdb_C7[msigdb_C7$gs_subcat == "IMMUNESIGDB",]

# Perform GSEA using clusterProfiler
immunesig_results <- GSEA(ranked_genes, 
                     TERM2GENE = immunesigdb_C7[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 0.05, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0,
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```

### Top 20 IMMUNESIGDB Pathways

```{r}
p <- custom_dotplot(gsea_obj = immunesig_results, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA enriched hallmark pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/GSEA_immunesig_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```





## Misc


```{r}
# Assuming DE results are already available from limma
immune_genes <- msigdbr(species = "Mus musculus", 
                        category = "C7", 
                        subcategory = "IMMUNESIGDB")  # C7 for immunologic gene sets

# Filter DE results for immune-related genes
immune_DEGs <- DE_KOvsWT[rownames(DE_KOvsWT) %in% immune_genes$gene_symbol, ]

# Visualization using heatmap
library(pheatmap)
pheatmap(log2(immune_DEGs + 1), scale = "row", main = "Immune-related DEGs")
```



