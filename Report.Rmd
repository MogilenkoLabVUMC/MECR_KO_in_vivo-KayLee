---
title: "MECR KO Report"
author: "Anton_Zhelonkin"
date: "`r Sys.Date()`"
output: 
  html_document:
    css: snippet.css  # Path to your custom CSS file
    toc: true
    theme: united
    number_sections: true # Number sections (optional)
    self_contained: false
---


```{r echo = FALSE}
##############################
## Prepairing the environment
##############################

# Don`t show code in the report set up 
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE,
                      fig.width=7, fig.height=5, dpi=300)

# cleaning sessionInfo
rm(list = ls())
# Reset graphical parameters
graphics.off()
# Reset options to default (optional)
options(default = TRUE)

#### Library preparation
# Install if necessary 
if (!requireNamespace("edgeR", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
        install.packages("BiocManager")
    }
    BiocManager::install("edgeR")
}

if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}

if (!requireNamespace("EnhancedVolcano", quietly = TRUE)) {
  BiocManager::install('EnhancedVolcano')
}


# attaching libraries
library(ggplot2)
library(edgeR)
library(EnhancedVolcano)
library(limma)
```


# 1. Data Preparation

Raw counts data were filtered using `edgeR`s function `filterByExpr` and normalized using standard `TMM` (trimmed mean of M values) method, which accounts for sequencing depth, RNA composition, and gene length, and is the standard recommended method in `edgeR`s vignette. For the exploratory visualisations read counts per million were calculated and log+1 transformed. 

```{r echo = FALSE, include = FALSE}
# Reading data
rawData_trimmed <- read.table('init_data/counts_matrix_trimmed.txt', 
                      header = TRUE, 
                      row.names = 1,
                      stringsAsFactors = FALSE)

# Assign sample names
colnames(rawData_trimmed) <- c('KO1', 'KO2', 'KO3', 'WT1', 'WT2', 'WT3')

# Strip daway metadata
# Check if there's any unwanted metadata row, e.g., 'Geneid', and remove it if necessary
# If the first row is metadata, you can drop it explicitly:
if ("Geneid" %in% rownames(rawData_trimmed)) {
  rawData_trimmed <- rawData_trimmed[-which(rownames(rawData_trimmed) == "Geneid"), ]
}

# Convert chr to int, preserving rownames - using [] to preserve row attributes
rawData_trimmed[] <- lapply(rawData_trimmed, as.integer)

# Check for any NA values (indicating conversion issues)
any_na <- any(is.na(rawData_trimmed))
# If any NA values are found, investigate
if (any_na) {
  print("Warning: Some non-numeric values were converted to NA. Please check your data.")
} else {
  print("No NAs introduced during values conversion")
}

# Create DGEList object
rawDGE_t <- DGEList(rawData_trimmed)

# Create a grouping factor 
group <- factor(
  c(
    rep("KO", 3),
    rep("WT", 3)
  )
)

# Add grouping to the DGEList object
rawDGE_t$samples$group <- group

# filtering genes by expression, getting rid of low count genes
keep <- filterByExpr(rawDGE_t)
rawDGE_t <- rawDGE_t[keep, , keep.lib.sizes=FALSE] # update lib sizes

# data normalization
rawDGE_t <- normLibSizes(rawDGE_t,
                              method = "TMM")

# Releveling the factor to set WT as the reference level for further modelling
rawDGE_t$samples$group<- relevel(rawDGE_t$samples$group, ref = "WT")

# calculating logCPM
logCPM <- cpm(rawDGE_t, log = TRUE, prior.count = 1)
```

<hr />

# 2. Exploratory analysis

## PCA

**PCA Data Preparation for Plotting**: : The first two principal components (PC1 and PC2) were extracted from the PCA results and combined with metadata (group/condition) and sample names.

```{r}
# Calculate PCA
pca <- prcomp(t(logCPM))

# Prepare PCA for plotting 
pca_data <- data.frame(
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  condition = rawDGE_t$samples$group,
  sample_names = colnames(logCPM)  # Assuming colnames are the sample names
)
```

**Variance Explained by Principal Components**: The proportion of variance explained by each principal component was calculated as a percentage. This provides context for interpreting the PCA plot by quantifying how much of the total variance is captured by PC1 and PC2.

```{r}
# Percent of PCA variance
percentVar <- pca$sdev^2 / sum(pca$sdev^2) * 100
```

**PCA Plot:** The PCA plot visualizes the first two principal components, with points representing individual samples. Points were colored and shaped according to the experimental condition (i.e., group).  

```{r}
require(ggplot2)
require(ggalt)

# Custom minimal theme 
# Custom theme with minimal style and grid lines
custom_minimal_theme_with_grid <- function() {
  theme_minimal() +
    theme(
      # Customize the axes
      axis.line = element_line(color = "black"),
      axis.ticks = element_line(color = "black"),
      axis.title.x = element_text(size = 12, face = "plain"),
      axis.title.y = element_text(size = 12, face = "plain"),
      axis.text.x = element_text(size = 10),
      axis.text.y = element_text(size = 10),
      # Major and minor grid lines with transparency
      panel.grid.major = element_line(color = "grey90", linewidth = 0.5),  # Major grid lines (lighter)
      panel.grid.minor = element_line(color = "grey95", linewidth = 0.25)   # Minor grid lines (even lighter)
    )
}

# Assuming you've already calculated the PCA and created pca_data
# Add batch information to pca_data
pca_data$group <- rawDGE_t$samples$group

# PCA plot with sample names
ggplot(pca_data, aes(x = PC1, y = PC2, color = condition, shape = condition)) +
  geom_point(size = 3) +
  geom_text(aes(label = sample_names), vjust = -1, hjust = 1, 
            size = 3,
            show.legend = FALSE) +  # Add sample names
  labs(color = "Condition", shape = "Condition") +
  xlab(paste0("PC1: ", round(percentVar[1], 1), "% variance")) +
  ylab(paste0("PC2: ", round(percentVar[2], 1), "% variance")) +
  ggtitle("Principal Component Analysis on the logCPM") +
  custom_minimal_theme_with_grid() +
  xlim(-90,110) +
  ylim(-80,80) +
  theme(
      legend.position = "inside",
      legend.position.inside = c(0.85,0.9),  # Use legend.position.inside for inside positioning
      legend.justification = c(0, 1),  # Align legend to top-left inside plot
      legend.box.background = element_rect(color = "black", linewidth = 0.5),  # Use linewidth instead of size
      legend.box.margin = margin(2, 2, 2, 2),  # Optional: Adjust margin around legend box
      plot.title = element_text(hjust=0.2, vjust=0.2, margin = margin(b=10)),
      plot.margin = margin(20,20,20,20)
  )
```

## Scree plot - Proportion of Variance explained by PCA

The major % of variance is explained by the first component. The first PCA has obivously captured the nice delineation between the WT and KO samples. 

```{r}
# Scree plot data preparation
scree_data <- data.frame(PC = 1:length(pca$sdev), 
                         var_explained = percentVar)

ggplot(scree_data, aes(x = PC, y = var_explained)) +
  geom_bar(stat = "identity") +
  xlab("Principal Component") +
  ylab("Proportion of Variance Explained") +
  ggtitle("Scree Plot") +
  custom_minimal_theme_with_grid()
```


## Samples heatmap

*Sample Correlation Matrix and Heatmap:* A sample correlation matrix was computed using Pearson correlation, quantifying the similarity in gene expression profiles between pairs of samples based on the logCPM values. This matrix reflects how closely samples relate to each other in terms of their overall expression patterns.  A heatmap of the sample correlation matrix was generated using the pheatmap() function. The heatmap displayed correlation values between samples, with annotations for experimental group and temperature shown for each sample.  

```{r echo = FALSE}
require(pheatmap)

# Sample correlation calculation
sample_cor <- cor(logCPM, method = "pearson")

# Correlation heatmap
pheatmap(sample_cor, 
         main = "Sample Correlation Heatmap",
         method = "ward.D")
```

<hr />

# 3. Statistical Modelling 

The design matrix for initial modelling has been set up using the formula: 

> Desing formula
  ```
  DEGs ~ group
  ```

...which basically means. Variable on the left-hand side of a tilde (~) is called the "dependent variable", while the variables on the right-hand side are called the "independent variables" and are joined by plus signs +. Variables joined by * sign, are interactions terms, i.e. we\`re interested in how the intereaction between variables influences the dependant variable. 

*Weighted limma-voom Transformation* 
To account for both sample quality and variability in read counts across samples, we applied the voomWithQualityWeights function from the limma package. This method incorporates sample-specific weights during normalization, ensuring that poor-quality samples have reduced influence on the differential expression analysis.  

```{r}
# Releveling the group factor variable
rawDGE_t$samples$group <- relevel(rawDGE_t$samples$group, ref = "WT")

# Setting the desing 
design <- model.matrix(~group, data = rawDGE_t$samples)
colnames(design) <- c("WT", "MecrKO")

## EdgeR`s voomLmFit does all this under the hood: logCPM, limmaWeighted, corfit, lmFit
fit <- edgeR::voomLmFit(counts = rawDGE_t,
                        design = design,
                        sample.weights = TRUE
                        )
# edgeR::voomLmFit performs limma`s voomWithQualityWeights with duplicateCorrelation
# If block is specified voom weights and intra-block correlation are each estimated twice

# Set the contrasts 
contrasts <- makeContrasts(
  # Overall treatment effect (across both batches)
  KOvsWT = MecrKO - WT,
  levels = design
)

# Compute contrasts from linear model
fit <- contrasts.fit(fit, contrasts)

# Compute moderated t-statistics
fit <- eBayes(fit)

# Extract contrast coefficients
## Overall treatment effect 
DE_KOvsWT <- topTable(fit, 
         coef="KOvsWT", 
         sort.by = "t",
         n=Inf)
```


```{r echo = FALSE}
#### Standard quantile normalisation approach 

# Read in the data (assuming you have your counts matrix)
#counts <- read.table('init_data/counts_matrix_trimmed.txt', 
#                     header = TRUE, 
#                     row.names = 1,
#                     stringsAsFactors = FALSE)


# Assign sample names
#colnames(counts) <- c('KO1', 'KO2', 'KO3', 'WT1', 'WT2', 'WT3')

# Strip away metadata
# Check if there's any unwanted metadata row, e.g., 'Geneid', and remove it if necessary
# If the first row is metadata, you can drop it explicitly:
#if ("Geneid" %in% rownames(counts)) {
#  counts <- counts[-which(rownames(counts) == "Geneid"), ]
#}

# Convert chr to int, preserving rownames - using [] to preserve row attributes
#counts[] <- lapply(counts, as.integer)

# Check for any NA values (indicating conversion issues)
#any_na <- any(is.na(counts))
# If any NA values are found, investigate
#if (any_na) {
#  print("Warning: Some non-numeric values were converted to NA. Please check your data.")
#} else {
#  print("No NAs introduced during values conversion")
#}


# Perform log2 transformation with pseudocount of 1
#log2_counts <- log2(counts + 1)

# Quantile normalize 
#quantile_normalized_counts <- normalizeBetweenArrays(log2_counts, method = "quantile")

# Calculate the average expression across samples
#AveExp <- rowMeans(quantile_normalized_counts)

# Filter out genes with average expression less than 3
#filtered_counts <- quantile_normalized_counts[AveExp >= 3, ]

# Prepare the design matrix
# Ensure that WT is the reference level for the group factor
#group <- factor(c(rep("KO", 3), rep("WT", 3)), levels = c("WT", "KO"))
#design <- model.matrix(~ group)
#colnames(design) <- c("WT", "MecrKO")

# Apply limma to the filtered data
#fit <- lmFit(filtered_counts, design)

# Set the contrasts 
#contrasts <- makeContrasts(
  # Overall treatment effect (across both batches)
#  KOvsWT = MecrKO - WT,
#  levels = design
#)

# Compute contrasts from linear model
#fit <- contrasts.fit(fit, contrasts)

#fit <- eBayes(fit)

# Get the results for KO vs WT comparison
#DE_standard_results <- topTable(fit, coef = "KOvsWT", adjust = "fdr", n = Inf)

```

```{r echo = FALSE}
#write.csv2(DE_KOvsWT, file = "results/DEtable/DE_KOvsWT.csv")
#write.table(DE_KOvsWT, file = "results/DEtable/DE_KOvsWT.txt", sep = "\t", quote = FALSE, row.names = TRUE, col.names = NA)
#write.table(DE_standard_results, file = "results/DEtable/DE_KOvsWT_st.txt", sep = "\t", quote = FALSE, row.names = TRUE, col.names = NA)
```

```{r echo = FALSE}
# Check that Trb genes are in the dataset

#grepl("Trb", rownames(DE_KOvsWT))

# Find rows where "Trb" is mentioned in the row names
#trb_genes <- grepl("Trb", rownames(DE_KOvsWT))

# Subset the table to show only rows that contain "Trb" in their row names
#DE_KOvsWT_trb <- DE_KOvsWT[trb_genes, ]

# View the results
#DE_KOvsWT_trb

```
 
```{r echo = FALSE}
##### STANDARD VOLCANO
# require(dplyr)
# 
# results_df <- DE_standard_results
# results_df$genes <- rownames(DE_standard_results)
# library(EnhancedVolcano)
# 
# top_genes <- c("Trbc2", "Trbc1", "Trbv1",
#                "Trbv19", "Trbv13-1", "Trbv13-2", "Trbv13-3",
#                "Trbv20", "Trbv5", "Trbv31",
#                "Trbv31", "Trbv3", "Trbv26",
#                "Trbv14", "Trbv12", "Trbv29", "Trbv4"
#                )
# 
# # Plot using EnhancedVolcano with the selected genes
# p <- EnhancedVolcano(results_df,
#     lab = results_df$genes,
#     x = 'logFC',
#     y = 'P.Value',
#     selectLab = top_genes,  # Only label the top 5 negative and positive DE genes
#     xlab = bquote(~Log[2]~ 'fold change'),
#     pCutoff = 0.05,
#     FCcutoff = 4.0,
#     pointSize = 2.0,
#     labSize = 6.0,
#     labCol = 'black',
#     labFace = 'bold',
#     boxedLabels = TRUE,
#     colAlpha = 4/5,
#     legendPosition = 'right',
#     legendLabSize = 14,
#     legendIconSize = 4.0,
#     drawConnectors = TRUE,
#     widthConnectors = 1.0,
#     colConnectors = 'black',
#     title = 'Volcano Plot',
#     subtitle = 'Differentially Expressed Genes in MECR-KO against WT',
#     caption = 'Thresholds: Log2FC > 4, P value < 0.05')
# 
# # Save the plot
# ggsave(
#   filename = "imgs/DE_all_volcano_Trb_st.png",  # Specify the file path and name
#   plot = p,  # The plot to save
#   width = 10, height = 8,  # Dimensions of the image in inches
#   dpi = 300  # Resolution of the image
# )
# 
# # Print the plot
# print(p)
```
 
 
```{r include = FALSE}
require(dplyr)

results_df <- DE_KOvsWT
results_df$genes <- rownames(DE_KOvsWT)

# Sort the data to get top 5 most negative and top 5 most positive DE genes
top_negative <- results_df %>%
  arrange(logFC) %>%
  slice_head(n = 5) %>%
  pull(genes)  # Get the gene names

top_positive <- results_df %>%
  arrange(desc(logFC)) %>%
  slice_head(n = 5) %>%
  pull(genes)  # Get the gene names

# Combine the top negative and positive DE genes for labeling
top_genes <- c(top_negative, top_positive)

# Color pallete
color_pallette <- c("gray", "forestgreen", "skyblue", "orange")

# Plot using EnhancedVolcano with the selected genes
p <- EnhancedVolcano(results_df,
    lab = results_df$genes,
    x = 'logFC',
    y = 'P.Value',
    selectLab = top_genes,  # Only label the top 5 negative and positive DE genes
    xlab = bquote(~Log[2]~ 'fold change'),
    pCutoff = 0.05,
    FCcutoff = 4.0,
    pointSize = 2.0,
    labSize = 6.0,
    labCol = 'black',
    labFace = 'bold',
    boxedLabels = TRUE,
    colAlpha = 4/5,
    legendPosition = 'right',
    legendLabSize = 14,
    legendIconSize = 4.0,
    drawConnectors = TRUE,
    widthConnectors = 1.0,
    colConnectors = 'black',
    title = 'Volcano Plot',
    subtitle = 'Differentially Expressed Genes in MECR-KO against WT',
    caption = 'Thresholds: Log2FC > 4, P value < 0.05',
    col = color_pallette
    )

# Save the plot
ggsave(
  filename = "imgs/DE_all_volcano.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)

# Print the plot
print(p)
```

```{r include = FALSE, eval = FALSE}
library(ggplot2)
library(dplyr)
library(ggrepel)

# Define a custom minimal theme
custom_minimal_theme_with_grid <- function() {
  theme_minimal(base_size = 14) +
    theme(
      panel.background = element_rect(fill = "white", color = NA), 
      plot.background = element_rect(fill = "white", color = NA),
      panel.grid.major = element_line(color = "grey80", size = 0.5),
      panel.grid.minor = element_line(color = "grey90", size = 0.25),
      axis.line = element_line(color = "black"),
      axis.ticks = element_line(color = "black"),
      axis.title.x = element_text(size = 14, face = "plain"),
      axis.title.y = element_text(size = 14, face = "plain"),
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12)
    )
}

# Main function to generate a basic volcano plot
create_volcano_plot <- function(de_results, p_cutoff = 0.05, fc_cutoff = 2.0, 
                                max_overlaps = 100, x_breaks = 1, color_pallette = c("gray", "forestgreen", "skyblue", "orange")) {

  # Prepare DE results with significance columns
  de_results <- de_results %>%
    mutate(
      significant_fc = abs(logFC) > fc_cutoff,
      significant_p = P.Value < p_cutoff,
      highlight = significant_fc & significant_p
    ) %>%
    # Add a color column based on the condition
    mutate(
      color = case_when(
        highlight ~ "p-value & Log2FC",   # Both significant fold change and p-value
        significant_fc ~ "Log2FC",        # Significant fold change only
        significant_p ~ "p-value",        # Significant p-value only
        TRUE ~ "NS"                       # Not significant
      )
    )
  
  # Define the x-axis limits based on the fold change
  x_min <- floor(min(de_results$logFC) / x_breaks) * x_breaks  # Start from nearest multiple <= min(logFC)
  x_max <- ceiling(max(de_results$logFC) / x_breaks) * x_breaks  # End at nearest multiple >= max(logFC)

  # Define base plot
  base_plot <- ggplot(de_results, aes(x = logFC, y = -log10(P.Value), color = color)) +
    geom_point(size = 2) +
    geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed", color = "red") +
    geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed", color = "blue") +
    scale_color_manual(values = c("NS" = color_pallette[1], "Log2FC" = color_pallette[2], "p-value" = color_pallette[3], "p-value & Log2FC" = color_pallette[4])) +
    labs(
      title = "Volcano Plot",
      subtitle = paste("p-value cutoff:", p_cutoff, "| FC cutoff:", fc_cutoff),
      x = bquote(~Log[2]~ 'Fold Change'),
      y = bquote(-Log[10]~ 'P-value')
    ) +
    scale_x_continuous(breaks = seq(x_min, x_max, by = x_breaks), limits = c(x_min, x_max)) +
    custom_minimal_theme_with_grid()

  # If there are significant genes, apply label repelling
  label_data <- de_results %>% filter(highlight)
  
  if (nrow(label_data) > 0) {
    base_plot <- base_plot + geom_label_repel(
      data = label_data,
      aes(label = rownames(label_data)),
      box.padding = 0.5,
      point.padding = 0.5,
      force = 5,
      segment.color = 'grey50',
      max.overlaps = max_overlaps
    )
  }

  return(base_plot)
}

# Example Usage:
# Assuming your DE data is stored in `DE_KOvsWT`
# Run the function to create the plot
volcano_plot <- create_volcano_plot(DE_KOvsWT, p_cutoff = 0.05, fc_cutoff = 2.0, color_pallette = c("gray", "forestgreen", "skyblue", "orange"))

# Print the plot
print(volcano_plot)

# Save the plot to a file if needed
ggsave(filename = "volcano_plot.png", plot = volcano_plot, width = 10, height = 8, dpi = 300)

```
```{r include = FALSE}
library(ggplot2)
library(dplyr)

# Define a custom minimal theme
custom_minimal_theme_with_grid <- function() {
  theme_minimal(base_size = 14) +
    theme(
      panel.background = element_rect(fill = "white", color = NA), 
      plot.background = element_rect(fill = "white", color = NA),
      panel.grid.major = element_line(color = "grey80", size = 0.5),
      panel.grid.minor = element_line(color = "grey90", size = 0.25),
      axis.line = element_line(color = "black"),
      axis.ticks = element_line(color = "black"),
      axis.title.x = element_text(size = 14, face = "plain"),
      axis.title.y = element_text(size = 14, face = "plain"),
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12)
    )
}

# Main function to generate a basic volcano plot without labeling genes and with alpha adjustment
create_volcano_plot <- function(de_results, p_cutoff = 0.05, fc_cutoff = 2.0, 
                                x_breaks = 1, color_pallette = c("gray", "forestgreen", "skyblue", "orange")) {

  # Prepare DE results with significance columns
  de_results <- de_results %>%
    mutate(
      significant_fc = abs(logFC) > fc_cutoff,
      significant_p = P.Value < p_cutoff,
      highlight = significant_fc & significant_p
    ) %>%
    # Add a color column based on the condition
    mutate(
      color = case_when(
        highlight ~ "p-value & Log2FC",   # Both significant fold change and p-value
        significant_fc ~ "Log2FC",        # Significant fold change only
        significant_p ~ "p-value",        # Significant p-value only
        TRUE ~ "NS"                       # Not significant
      )
    )
  
  # Define the x-axis limits based on the fold change
  x_min <- floor(min(de_results$logFC) / x_breaks) * x_breaks  # Start from nearest multiple <= min(logFC)
  x_max <- ceiling(max(de_results$logFC) / x_breaks) * x_breaks  # End at nearest multiple >= max(logFC)

  # Define base plot
  base_plot <- ggplot(de_results, aes(x = logFC, y = -log10(P.Value), color = color)) +
    geom_point(size = 2, alpha = 0.5) +  # Set alpha to 0.5 for transparency
    geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed", color = "red") +
    geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed", color = "blue") +
    scale_color_manual(values = c("NS" = color_pallette[1], "Log2FC" = color_pallette[2], "p-value" = color_pallette[3], "p-value & Log2FC" = color_pallette[4]),
                       name = NULL  # This removes the legend title
                       ) +
    labs(
      title = "Volcano Plot",
      subtitle = paste("p-value cutoff:", p_cutoff, "| FC cutoff:", fc_cutoff),
      x = bquote(~Log[2]~ 'FC'),
      y = bquote(-Log[10]~ 'P')
    ) +
    scale_x_continuous(breaks = seq(x_min, x_max, by = x_breaks), limits = c(x_min, x_max)) +
    custom_minimal_theme_with_grid()

  return(base_plot)
}

# Example Usage:
# Assuming your DE data is stored in `DE_KOvsWT`
volcano_plot <- create_volcano_plot(DE_KOvsWT, p_cutoff = 0.05, fc_cutoff = 4.0, color_pallette = c("gray", "forestgreen", "skyblue", "orange"))

# Print the plot
print(volcano_plot)

# Save the plot to a file if needed
ggsave(filename = "volcano_plot.png", plot = volcano_plot, width = 10, height = 8, dpi = 300)

```

### Interactive Volcano Plot

```{r}
library(ggplot2)
library(dplyr)
library(plotly)  # Load plotly for interactivity

# Define a custom minimal theme
custom_minimal_theme_with_grid <- function() {
  theme_minimal(base_size = 14) +
    theme(
      panel.background = element_rect(fill = "white", color = NA), 
      plot.background = element_rect(fill = "white", color = NA),
      panel.grid.major = element_line(color = "grey80", size = 0.5),
      panel.grid.minor = element_line(color = "grey90", size = 0.25),
      axis.line = element_line(color = "black"),
      axis.ticks = element_line(color = "black"),
      axis.title.x = element_text(size = 14, face = "plain"),
      axis.title.y = element_text(size = 14, face = "plain"),
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12)
    )
}

# Main function to generate a basic volcano plot without labeling genes and with alpha adjustment
create_volcano_plot <- function(de_results, p_cutoff = 0.05, fc_cutoff = 2.0, 
                                x_breaks = 1, color_pallette = c("gray", "forestgreen", "skyblue", "orange")) {

  # Add hover text to DE results
  de_results <- de_results %>%
    mutate(
      significant_fc = abs(logFC) > fc_cutoff,
      significant_p = P.Value < p_cutoff,
      highlight = significant_fc & significant_p,
      hover_text = paste("Gene:", rownames(de_results), 
                         "<br>LogFC:", round(logFC, 2),
                         "<br>P-value:", formatC(P.Value, format = "e", digits = 2))
    ) %>%
    # Add a color column based on the condition
    mutate(
      color = case_when(
        highlight ~ "p-value & Log2FC",   # Both significant fold change and p-value
        significant_fc ~ "Log2FC",        # Significant fold change only
        significant_p ~ "p-value",        # Significant p-value only
        TRUE ~ "NS"                       # Not significant
      )
    )
  
  # Define the x-axis limits based on the fold change
  x_min <- floor(min(de_results$logFC) / x_breaks) * x_breaks  # Start from nearest multiple <= min(logFC)
  x_max <- ceiling(max(de_results$logFC) / x_breaks) * x_breaks  # End at nearest multiple >= max(logFC)

  # Define base plot with hover info
  base_plot <- ggplot(de_results, aes(x = logFC, y = -log10(P.Value), color = color, text = hover_text)) +
    geom_point(size = 2, alpha = 0.5) +  # Set alpha to 0.5 for transparency
    geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed", color = "red") +
    geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed", color = "blue") +
    scale_color_manual(values = c("NS" = color_pallette[1], "Log2FC" = color_pallette[2], "p-value" = color_pallette[3], "p-value & Log2FC" = color_pallette[4]),
                       name = NULL  # This removes the legend title
                       ) +
    labs(
      title = "Volcano Plot",
      subtitle = paste("p-value cutoff:", p_cutoff, "| FC cutoff:", fc_cutoff),
      x = "Log2FC",   # Use plain text for x-axis label
      y = "-Log10P"      # Use plain text for y-axis label
    ) +
    scale_x_continuous(breaks = seq(x_min, x_max, by = x_breaks), limits = c(x_min, x_max)) +
    custom_minimal_theme_with_grid()

  return(base_plot)
}

# Example Usage:
# Assuming your DE data is stored in `DE_KOvsWT`
volcano_plot <- create_volcano_plot(DE_KOvsWT, p_cutoff = 0.05, fc_cutoff = 4.0, color_pallette = c("gray", "forestgreen", "skyblue", "orange"))

# Convert to an interactive plot using plotly
interactive_volcano_plot <- ggplotly(volcano_plot, tooltip = "text")

interactive_width = 700
interactive_height = 500

# Convert to an interactive plot using plotly with specific dimensions
interactive_volcano_plot <- ggplotly(volcano_plot, tooltip = "text") %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

# Print the interactive plot
interactive_volcano_plot

# Save the interactive plot as an HTML file if needed
htmlwidgets::saveWidget(interactive_volcano_plot, "volcano_plot_interactive.html")
```


```{r include = FALSE}
# require(dplyr)
# 
# trb_genes <- c("Trbc2", "Trbc1", "Trbv1",
#                "Trbv19", "Trbv13-1", "Trbv13-2", "Trbv13-3",
#                "Trbv20", "Trbv5", "Trbv31",
#                "Trbv31", "Trbv3", "Trbv26",
#                "Trbv14", "Trbv12", "Trbv29", "Trbv4"
#                )
# 
# # Plot using EnhancedVolcano with the selected genes
# p <- EnhancedVolcano(results_df,
#     lab = results_df$genes,
#     x = 'logFC',
#     y = 'P.Value',
#     selectLab = trb_genes,  # Only label the top 5 negative and positive DE genes
#     xlab = bquote(~Log[2]~ 'fold change'),
#     pCutoff = 0.05,
#     FCcutoff = 4.0,
#     pointSize = 2.0,
#     labSize = 6.0,
#     labCol = 'black',
#     labFace = 'bold',
#     boxedLabels = TRUE,
#     colAlpha = 4/5,
#     legendPosition = 'right',
#     legendLabSize = 14,
#     legendIconSize = 4.0,
#     drawConnectors = TRUE,
#     widthConnectors = 1.0,
#     colConnectors = 'black',
#     title = 'Volcano Plot',
#     subtitle = 'Differentially Expressed Genes in MECR-KO against WT',
#     caption = 'Thresholds: Log2FC > 4, adjusted P value < 0.05',
#     col = color_pallette)
# 
# # Save the plot
# ggsave(
#   filename = "imgs/DE_all_volcano_Trb_limma.png",  # Specify the file path and name
#   plot = p,  # The plot to save
#   width = 10, height = 8,  # Dimensions of the image in inches
#   dpi = 300  # Resolution of the image
# )
# 
# # Print the plot
# print(p)
```

<hr />

# 4. Gene Set Enrichment Analysis

Gene set enrichment analysis was performed using the `clusterProfiler` package.
We tested pathway enrichment against `msigdbr` genesets database. 
* Hallmark Pathways
* ImmuneSigDB subset of C7 - Gene sets representing chemical and genetic perturbations of the immune system generated by manual curation of published studies in human and mouse immunology
* REACTOME
* GO
* MF: subset of GO - Gene sets derived from the GO Molecular Function ontology. 
The ranked gene list for the GSEA was ranked based on the moderated t-statistic. 


## 4.1 MSigDB Hallmark Pathways enrichment analysis

```{r}
##########
# Define functions
##########


###############
### Custom GSEA plot function
###############

library(ggplot2)
library(dplyr)
library(stringr)
library(scales)

# Define custom dotplot function for GSEA objects with text processing and sorting options
custom_dotplot <- function(gsea_obj, showCategory = 10, font.size = 10, title = "GSEA Dotplot",
                           replace_ = TRUE, capitalize_1 = TRUE, capitalize_all = FALSE, 
                           filterBy = "qvalue",
                           sortBy = "GeneRatio",
                           q_cut = 0.05,
                           min.dotSize = 2) {
  
  # Extract the result data frame from the GSEA object
  gsea_data <- as.data.frame(gsea_obj@result)
  
  # Calculate the gene count from 'core_enrichment' by counting '/' and adding 1 (number of genes)
  gene_count <- gsea_data %>%
    group_by(ID) %>%
    summarise(count = sum(str_count(core_enrichment, "/")) + 1)
  
  # Merge gene counts with the original GSEA result and calculate GeneRatio
  gsea_data <- left_join(gsea_data, gene_count, by = "ID") %>%
    mutate(GeneRatio = count / setSize)
  
  # Modify Description field based on function arguments
  if (replace_) {
    gsea_data$Description <- gsea_data$Description %>% 
      str_replace_all("_", " ")   # Replace "_" with " " if 'replace' is TRUE
  }
  
  if (capitalize_1) {
    gsea_data$Description <- gsea_data$Description %>%
      str_to_sentence()           # Capitalize only the first word if 'capitalize_1' is TRUE
  }
  
  if (capitalize_all) {
    gsea_data$Description <- gsea_data$Description %>%
      str_to_title()              # Capitalize all words if 'capitalize_all' is TRUE
  }
  
  # Filter for significant pathways (qvalue < 0.01)
  gsea_data_filtered <- gsea_data %>%
    filter(qvalue < q_cut) %>%
    mutate(NES_sign = ifelse(NES > 0, "Positive NES", "Negative NES"))
  
  # Filter logic based on 'filterBy' argument
  if (filterBy == "qvalue") {
    # Sort by qvalue (default behavior)
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(qvalue) %>%           # Sort by qvalue (ascending)
      head(showCategory)
  } else if (filterBy == "NES") {
    # Sort by absolute NES value (strongest enrichment)
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(desc(abs(NES))) %>%    # Sort by absolute NES (descending)
      head(showCategory)
  } else if (filterBy == "NES_positive") {
    # Filter and sort by positive NES values only
    gsea_data_filtered <- gsea_data_filtered %>%
      filter(NES > 0) %>%           # Filter positive NES
      arrange(desc(NES)) %>%        # Sort by NES (descending)
      head(showCategory)
  } else if (filterBy == "NES_negative") {
    # Filter and sort by negative NES values only
    gsea_data_filtered <- gsea_data_filtered %>%
      filter(NES < 0) %>%           # Filter negative NES
      arrange(NES) %>%              # Sort by NES (ascending, more negative first)
      head(showCategory)
  }

 # Sort the filtered data based on the sortBy parameter
  if (sortBy == "GeneRatio") {
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(desc(GeneRatio))
  } else if (sortBy == "qvalue") {
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(qvalue)
  } else {
    warning("Invalid sortBy parameter. Defaulting to GeneRatio.")
    gsea_data_filtered <- gsea_data_filtered %>%
      arrange(desc(GeneRatio))
  }

  # Take the top showCategory entries after sorting
  gsea_data_filtered <- gsea_data_filtered %>%
    head(showCategory)

  # Create custom dotplot using ggplot2
  ggplot(gsea_data_filtered, aes(x = GeneRatio, y = reorder(Description, !!sym(sortBy)))) +
    geom_point(aes(size = -log10(qvalue), color = NES_sign)) +
    scale_color_manual(values = c("Positive NES" = "orange", "Negative NES" = "skyblue")) +
    
    # Use scale_size_continuous to set visual size limits for the dots
    scale_size_continuous(range = c(min.dotSize, 10),
                          limits = c(min(-log10(gsea_data_filtered$qvalue)), 
                                     max(-log10(gsea_data_filtered$qvalue))),
                          name = "-log10(qvalue)") +
    labs(
      title = title,
      x = "GeneRatio",
      y = NULL,
      color = "NES",
      size = "-log10(qvalue)"
    ) +
    
    custom_minimal_theme_with_grid() +
    theme(
      panel.background = element_rect(fill = "white", color = NA),  # White background with black border
      plot.background = element_rect(fill = "white", color = NA),  # White plot background with no border
      axis.text.y = element_text(size = font.size, hjust = 1),
      plot.title = element_text(hjust = 0.5, size = font.size + 2),
      axis.text.x = element_text(size = font.size),
      legend.position = "right"
    )
}
```



```{r echo = FALSE}
library(org.Mm.eg.db)  # Mouse-specific annotation
library(msigdbr) # MSigDB
library(clusterProfiler)


# Prepare the ranked gene list (from limma results)
# Rank by logFC or another relevant statistic

# Rank by t.value
ranked_genes <- DE_KOvsWT$t
names(ranked_genes) <- rownames(DE_KOvsWT) # Ensure Gene column contains gene symbols

# Sort genes by t (or other ranking criterion), just in case it hasn`t been sorted already
ranked_genes <- sort(ranked_genes, decreasing = TRUE)

# Retrieve Mouse Hallmark gene sets from MSigDB
msigdb_H <- msigdbr(species = "Mus musculus", 
                    category = "H")  # "H" is for hallmark gene sets

# Perform GSEA using clusterProfiler
GSE_H <- GSEA(ranked_genes, 
                     TERM2GENE = msigdb_H[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0,
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```


### All Hallmark pathways



```{r fig.width=10, fig.height=8}
p <- custom_dotplot(gsea_obj = GSE_H, 
               showCategory = 50, 
               font.size = 10, 
               title = "Top MECR-KO GSEA: All hallmark pathways",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE, 
               min.dotSize = 2
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_H)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold, linetype = "dashed", color = "red", size = 0.5) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/GSEA_Hallmark_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


### Top 20 Hallmark Pathways



```{r fig.width=10, fig.height=8}
p <- custom_dotplot(gsea_obj = GSE_H, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA enriched hallmark pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/GSEA_Hallmark_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```



### Running score plots 


#### Top 5 Pathways running score plot 


```{r}
library(enrichplot)

p <- gseaplot2(GSE_H, geneSetID = 1:5)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_top5.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

```{r}
# Define the custom function to plot GSEA results
plot_gsea_results <- function(gsea_results, n_plots = 12) {
  # Load required libraries
  library(cowplot)
  library(ggplot2)

  # Create an empty list to store the plots
  plot_list <- list()

  # Loop through geneSetID 1 to n_plots and generate the plots
  for (i in 1:n_plots) {
    # Replace underscores with spaces in the title
    plot_title <- gsub("_", " ", gsea_results$Description[i])
    
    # Generate each plot using gseaplot
    p <- gseaplot(gsea_results, 
                  geneSetID = i, 
                  by = "runningScore", 
                  title = plot_title)  # Use the modified title with spaces
    
    # Apply theme modifications: smaller x and y axis titles and bold plot title
    p <- p + theme(
      axis.title.x = element_text(size = 10),  # Set smaller x-axis title size
      axis.title.y = element_text(size = 10),  # Set smaller y-axis title size
      plot.title = element_text(face = "bold", size = 12, hjust = 0.5)  # Bold and center plot title
    )
    
    # Remove y-axis text but keep individual ticks and breaks for plots not in the first column
    if (i %% 3 != 1) {  # If the plot is not in the first column
      p <- p + theme(axis.title.y = element_blank())  # Only remove the y-axis title, not the ticks or labels
    }
    
    # Remove x-axis text only for plots that are not in the last row
    # Calculate how many rows there are and find which plots are in the last row
    rows <- ceiling(n_plots / 3)  # Number of rows
    last_row_plots <- (rows - 1) * 3 + 1:n_plots %% 3
    
    if (i <= (rows - 1) * 3) {  # If the plot is not in the last row
      p <- p + theme(axis.title.x = element_blank(),
                     axis.text.x = element_blank(),
                     axis.ticks.x = element_blank())
    }
    
    # Add the plot to the list
    plot_list[[i]] <- p
  }

  # Combine all the plots into a 3-column grid using cowplot
  combined_plot <- plot_grid(plotlist = plot_list, ncol = 3)


  # Optionally, return the plot object
  return(combined_plot)
}
```


```{r fig.width=14, fig.height=8, include = FALSE}
# Display the top 12 pathways:
p12 <- plot_gsea_results(GSE_H, n_plots = 12)
p12
# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_top12.png",  # Specify the file path and name
  plot = p12,  # The plot to save
  width = 14, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


#### Top 24 running score plot 


```{r fig.width=14, fig.height=18}
# Display top 24 pathways
p24 <- plot_gsea_results(GSE_H, n_plots = 24)
p24

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_top24.png",  # Specify the file path and name
  plot = p24,  # The plot to save
  width = 14, height = 18,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```



### Pathway-specific Plots

```{r}
##################
### Combined Volcano Plot Function with Multiple Styles
##################

library(ggplot2)
library(dplyr)
library(stringr)
library(ggrepel)

##################
### Combined Volcano Plot Function with Multiple Styles and p_method option
##################

library(ggplot2)
library(dplyr)
library(stringr)
library(ggrepel)

# Custom theme with minimal style and grid (used in multiple styles)
custom_minimal_theme_with_grid <- function() {
  theme_minimal(base_size = 14) +
    theme(
      panel.background = element_rect(fill = "white", color = NA), 
      plot.background = element_rect(fill = "white", color = NA),
      panel.grid.major = element_line(color = "grey80", size = 0.5),
      panel.grid.minor = element_line(color = "grey90", size = 0.25),
      axis.line = element_line(color = "black"),
      axis.ticks = element_line(color = "black"),
      axis.title.x = element_text(size = 14, face = "plain"),
      axis.title.y = element_text(size = 14, face = "plain"),
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12)
    )
}

# Main function to generate the volcano plot with different styles
analyze_pathway_volcano <- function(pathway_name, gsea_results, de_results, 
                                    p_cutoff = 0.05, fc_cutoff = 2.0, 
                                    label_method = "default", max_overlaps = 100, 
                                    style = 'clean', x_breaks = 1, 
                                    p_method = "P.Value") {  # Add p_method parameter with default
  
  # Step 1: Extract the relevant genes for the specified pathway
  message("Extracting genes for the pathway: ", pathway_name)
  pathway_genes <- as.data.frame(gsea_results) %>%
    filter(Description == pathway_name) %>%
    pull(core_enrichment) %>% 
    str_split("/", simplify = TRUE) %>% 
    as.vector()

  # Step 2: Prepare DE results and identify pathway genes
  message("Preparing DE results...")
  de_results <- de_results %>%
    mutate(
      in_pathway = rownames(.) %in% pathway_genes,
      significant_fc = abs(logFC) > fc_cutoff,
      significant_p = get(p_method) < p_cutoff,  # Use the chosen p-value method
      highlight = significant_fc & significant_p
    ) %>%
    # Add a color column based on the condition
    mutate(
      color = case_when(
        highlight ~ "p-value & Log2FC",   # Both significant fold change and p-value
        significant_fc ~ "Log2FC",        # Significant fold change only
        significant_p ~ "p-value",        # Significant p-value only
        TRUE ~ "NS"                       # Not significant
      )
    )
  
  # Determine labeling data based on method
  label_data <- switch(
    label_method,
    "default" = de_results %>% filter(in_pathway & highlight),  # Only label pathway genes with both p-value & Log2FC significant
    "fc" = de_results %>% filter(in_pathway & abs(logFC) > fc_cutoff),  # Label pathway genes crossing fold change threshold
    "p" = de_results %>% filter(in_pathway & get(p_method) < p_cutoff),  # Label pathway genes crossing p-value threshold
    "all" = de_results %>% filter(in_pathway & (abs(logFC) > fc_cutoff | get(p_method) < p_cutoff)),  # Label all significant pathway genes (either p-value or fold change)
    stop("Invalid label_method. Please use 'default', 'fc', 'p', or 'all'.")
  )
  
  # Determine the x-axis limits based on the user-defined x_breaks
  x_min <- floor(min(de_results$logFC) / x_breaks) * x_breaks  # Start from nearest multiple <= min(logFC)
  x_max <- ceiling(max(de_results$logFC) / x_breaks) * x_breaks  # End at nearest multiple >= max(logFC)

  
  # Determine y axis label dynamically 
    y_axis_label <- if (p_method == "P.Value") {
    bquote(-Log[10]~P)  # Use subscript for Log10 when p_method is P.Value
  } else {
    bquote(-Log[10]*"("*.(p_method)*")")  # Use p_method dynamically in the label
  }
  
 # Step 3: Define base plot based on the chosen p_method
  base_plot <- ggplot(de_results, aes(x = logFC, y = -log10(get(p_method)))) +
    geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed") +
    geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed") +
    labs(
      title = gsub("_", " ", pathway_name),
      subtitle = paste("p-value cutoff:", p_cutoff, "| FC cutoff:", fc_cutoff),
      x = bquote(-Log[2]~FC),
      # Conditional y-axis label based on the p_method parameter with proper subscript for "10"
      y = y_axis_label  # Use the dynamically created y-axis label
    ) +
    # Set x-axis breaks based on user-defined x_breaks
    scale_x_continuous(breaks = seq(x_min, x_max, by = x_breaks), limits = c(x_min, x_max))

  # Step 4: Choose plot style based on user input
  plot <- switch(
    style,
    'clean' = plot_style_clean(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    'claude' = plot_style_claude(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    'gpt' = plot_style_gpt(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    stop("Invalid style. Please use 'clean', 'claude', or 'gpt'.")
  )
  
  return(plot)
}


# Style 1: Clean style (original first style)
plot_style_clean <- function(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps) {
  # Define the colors for each condition
  colors <- c(
    "NS" = "#999999",               # Not significant
    "p-value & Log2FC" = "#E69F00", # Both p-value and Log2FC significant
    "p-value" = "#56B4E9"           # Only p-value significant
  )
  
  # Filter for pathway-specific data with different highlight criteria
  pathway_data <- de_results %>% filter(in_pathway)
  
  # Base plot with grey points for non-pathway genes
  plot <- base_plot +
    # Non-pathway genes in grey
    geom_point(data = de_results %>% filter(!in_pathway), 
               aes(color = "NS", alpha = 0.3), size = 1) +
    
    # Pathway genes: highlight based on p-value and fold change significance
    geom_point(data = pathway_data %>% filter(highlight), 
               aes(color = "p-value & Log2FC", alpha = 0.7), size = 1.5) +
    
    # Pathway genes: highlight based only on p-value significance
    geom_point(data = pathway_data %>% filter(!highlight & significant_p), 
               aes(color = "p-value", alpha = 0.7), size = 1.5) +
    
    # Set color scale manually and remove legend
    scale_color_manual(values = colors) +
    
    # Apply the custom minimal theme (assuming you have this function defined)
    custom_minimal_theme_with_grid() +
    theme(legend.position = "none")  # Remove the legend entirely
  
  # If there are genes to label, apply label repelling
  if (nrow(label_data) > 0) {
    plot <- plot + geom_label_repel(
      data = label_data,
      aes(label = rownames(label_data)),
      box.padding = 0.5,
      point.padding = 0.5,
      force = 5,
      segment.color = 'grey50',
      max.overlaps = max_overlaps
    )
  }
  
  return(plot)
}


# Style 2: Claude style (second version with enhanced volcano-style legend)
plot_style_claude <- function(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps) {
  colors <- c(
    "NS" = "#999999", "p-value" = "#56B4E9", "Log2FC" = "#0072B2", "p-value & Log2FC" = "#E69F00"
  )
  
  plot <- base_plot +
    geom_point(data = de_results %>% filter(!in_pathway), 
               color = "#CCCCCC", alpha = 0.3, size = 0.6) +
    geom_point(data = de_results %>% filter(in_pathway), 
               aes(color = color), alpha = 0.7, size = 1.5) +
    scale_color_manual(values = colors, 
                       name = "Significance",
                       labels = c("NS" = "NS", "p-value" = "p-value",
                                  "Log2FC" = "Log2FC", "p-value & Log2FC" = "p-value & Log2FC")) +
    custom_minimal_theme_with_grid() +
    theme(
      panel.background = element_rect(fill = "white", color = "black"),
      plot.background = element_rect(fill = "white", color = NA),
      legend.position = c(0.95, 0.95),
      legend.justification = c("right", "top"),
      legend.background = element_rect(fill = "white", color = "black")
    )
  
  if (nrow(label_data) > 0) {
    plot <- plot + geom_label_repel(
      data = label_data,
      aes(label = rownames(label_data)),
      box.padding = 0.5,
      point.padding = 0.5,
      force = 5,
      segment.color = 'grey50',
      max.overlaps = max_overlaps
    )
  }
  
  return(plot)
}

# Style 3: GPT style (third version with no alpha in legend)
plot_style_gpt <- function(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps) {
  colors <- c("NS" = "#999999", "Log2FC" = "#0072B2", "p-value" = "#56B4E9", "p-value & Log2FC" = "#E69F00")
  
  plot <- base_plot +
    geom_point(data = de_results %>% filter(!in_pathway), 
               aes(color = color, alpha = 0.2), size = 0.6) +
    geom_point(data = de_results %>% filter(in_pathway), 
               aes(color = color, alpha = 0.7), size = 1.5) +
    scale_color_manual(values = colors) +
    custom_minimal_theme_with_grid()+
    theme(legend.position = c(0.9, 0.9)) +
    guides(
      color = guide_legend(title = "Gene Status", override.aes = list(alpha = 1, size = 4)),
      alpha = "none"  # Remove alpha from legend
    )
  
  if (nrow(label_data) > 0) {
    plot <- plot + geom_label_repel(
      data = label_data,
      aes(label = rownames(label_data)),
      box.padding = 0.5,
      point.padding = 0.5,
      force = 5,
      segment.color = 'grey50',
      max.overlaps = max_overlaps
    )
  }
  
  return(plot)
}
```

```{r}
##################
### Combined Volcano Interactive: Claude with GPT Plotly Hover and p_method logic
##################

library(ggplot2)
library(dplyr)
library(stringr)
library(ggrepel)
library(plotly)  # Add plotly for interactivity

# Modify the analyze_pathway_volcano function to return a plotly object with hover
analyze_pathway_volcano_interactive <- function(pathway_name, gsea_results, de_results, 
                                                p_cutoff = 0.05, fc_cutoff = 2.0, 
                                                label_method = "default", max_overlaps = 100, 
                                                style = 'clean', x_breaks = 2,
                                                p_method = "P.Value") {  # Add p_method parameter
  
  # Extract the relevant genes for the specified pathway
  message("Extracting genes for the pathway: ", pathway_name)
  pathway_genes <- as.data.frame(gsea_results) %>%
    filter(Description == pathway_name) %>%
    pull(core_enrichment) %>% 
    str_split("/", simplify = TRUE) %>% 
    as.vector()

  # Prepare DE results and identify pathway genes
  message("Preparing DE results...")
  de_results <- de_results %>%
    mutate(
      in_pathway = rownames(.) %in% pathway_genes,  # Mark pathway genes
      significant_fc = abs(logFC) > fc_cutoff,
      significant_p = get(p_method) < p_cutoff,  # Use the chosen p-value method dynamically
      highlight = significant_fc & significant_p,
      hover_info = paste("Gene:", rownames(.),
                         "<br>Log2FC:", round(logFC, 2),
                         "<br>", p_method, ":", round(get(p_method), 5))  # Dynamic hover text with gene info
    ) %>%
    # Add a color column based on the condition
    mutate(
      color = case_when(
        highlight ~ "p-value & Log2FC",   # Both significant fold change and p-value
        significant_fc ~ "Log2FC",        # Significant fold change only
        significant_p ~ "p-value",        # Significant p-value only
        TRUE ~ "NS"                       # Not significant
      )
    )
  
  # Determine labeling data based on method
  label_data <- switch(
    label_method,
    "default" = de_results %>% filter(in_pathway & highlight),  # Only label pathway genes with both p-value & Log2FC significant
    "fc" = de_results %>% filter(in_pathway & abs(logFC) > fc_cutoff),  # Label pathway genes crossing fold change threshold
    "p" = de_results %>% filter(in_pathway & get(p_method) < p_cutoff),  # Label pathway genes crossing p-value threshold
    "all" = de_results %>% filter(in_pathway & (abs(logFC) > fc_cutoff | get(p_method) < p_cutoff)),  # Label all significant pathway genes (either p-value or fold change)
    stop("Invalid label_method. Please use 'default', 'fc', 'p', or 'all'.")
  )

  # Determine the x-axis limits based on the user-defined x_breaks
  x_min <- floor(min(de_results$logFC) / x_breaks) * x_breaks  # Start from nearest multiple <= min(logFC)
  x_max <- ceiling(max(de_results$logFC) / x_breaks) * x_breaks  # End at nearest multiple >= max(logFC)

  # Define y-axis label as a string for plotly compatibility
  y_axis_label <- if (p_method == "P.Value") {
    "-Log10 P"
  } else {
    paste0("-Log10(", p_method, ")")
  }

  # Define base plot with hover information and color mapping
  base_plot <- ggplot(de_results, aes(x = logFC, y = -log10(get(p_method)), 
                                      text = hover_info, color = in_pathway)) +
    geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed") +
    geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed") +
    labs(
      title = gsub("_", " ", pathway_name),
      subtitle = paste("p-value cutoff:", p_cutoff, "| FC cutoff:", fc_cutoff),
      x = "Log2FC",
      y = y_axis_label  # Use the dynamically created y-axis label as a string
    ) +
    # Set x-axis breaks based on user-defined x_breaks, ensuring alignment with the breaks pattern
    scale_x_continuous(breaks = seq(x_min, x_max, by = x_breaks), limits = c(x_min, x_max)) +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "grey")) +  # Pathway genes in red, others in grey
    custom_minimal_theme_with_grid()

  # Choose plot style based on user input
  ggplot_obj <- switch(
    style,
    'clean' = plot_style_clean(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    'claude' = plot_style_claude(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    'gpt' = plot_style_gpt(base_plot, de_results, pathway_genes, label_data, p_cutoff, fc_cutoff, max_overlaps),
    stop("Invalid style. Please use 'clean', 'claude', or 'gpt'.")
  )
  
  # Convert ggplot object to plotly for interactivity
  plotly_obj <- ggplotly(ggplot_obj, tooltip = c("text"))  # Use the custom hover text
  
  return(plotly_obj)
}
```



#### Myc pathway 


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "HALLMARK_MYC_TARGETS_V1",
  gsea_results = GSE_H,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05, 
  p_method = "P.Value",
  fc_cutoff = 4.0,
  label_method = "p",  # or "fc"
  max_overlaps = 100, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/Hallmark/Myc.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "HALLMARK_MYC_TARGETS_V1",
  gsea_results = GSE_H,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 4.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/Hallmark/Myc.html")
```

```{r}
title = "HALLMARK MYC TARGETS V1"

p <- gseaplot(GSE_H, 
              geneSetID = 1, 
              by = "runningScore", 
              title = title)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_Myc.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 5,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


#### MTORC1 pathway


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "HALLMARK_MTORC1_SIGNALING",
  gsea_results = GSE_H,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 4.0,
  label_method = "p",  # or "fc"
  max_overlaps = 60, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/Hallmark/MTORC1.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "HALLMARK_MTORC1_SIGNALING",
  gsea_results = GSE_H,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 4.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/Hallmark/MTORC1.html")
```

```{r}
title = "HALLMARK MTORC1 SIGNALING"

p <- gseaplot(GSE_H, 
              geneSetID = 5, 
              by = "runningScore", 
              title = title)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_MTORC1.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 5,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

#### PI3K-AKT-MTOR pathway


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "HALLMARK_PI3K_AKT_MTOR_SIGNALING",
  gsea_results = GSE_H,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 4.0,
  label_method = "p",  # or "fc"
  max_overlaps = 50, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/Hallmark/PI3K-AKT-MTOR.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "HALLMARK_PI3K_AKT_MTOR_SIGNALING",
  gsea_results = GSE_H,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/Hallmark/PI3K-AKT-MTOR.html")
```


```{r}
title = "HALLMARK MYC TARGETS V1"

p <- gseaplot(GSE_H, 
              geneSetID = 1, 
              by = "runningScore", 
              title = title)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/Hallmark/RunningScore_Myc.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 5,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

<hr />

## 4.2 MSigDB C5 Gene Ontology Molecular Function Sets enrichment analysis


```{r echo = FALSE}
library(org.Mm.eg.db)  # Mouse-specific annotation
library(msigdbr) # MSigDB
library(clusterProfiler)

# Prepare the ranked gene list (from limma results)
# Rank by logFC or another relevant statistic


# Retrieve C5 Gen Ontologygene sets from MSigDB
msigdb_C5 <- msigdbr(species = "Mus musculus", 
                     category = "C5",
                     subcategory = "MF")

# Perform GSEA using clusterProfiler
GSE_GO <- GSEA(ranked_genes, 
                     TERM2GENE = msigdb_C5[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0, # p value is not 
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```

### All GO Pathways


```{r fig.width=10, fig.height=14}
p <- custom_dotplot(gsea_obj = GSE_GO, 
               showCategory = 100, 
               font.size = 10, 
               title = "MECR-KO GSEA GO pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_GO)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold-0.01, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

# Strip "GOMF_" from pathway names by modifying the plot's data
p$data$Description <- gsub("^GOMF", "", p$data$Description)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/GO/GSEA_GO_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 14, height = 16,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```



### Top 20 GO:MF Pathways


```{r fig.width=10, fig.height=8}
p <- custom_dotplot(gsea_obj = GSE_GO, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA GO:MF pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Strip "GOMF_" from pathway names by modifying the plot's data
p$data$Description <- gsub("^GOMF", "", p$data$Description)

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/GO/GSEA_GO_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```




## Running score plots


```{r fig.width=14, fig.height=8, include = FALSE}
# Display the top 12 pathways:
p12 <- plot_gsea_results(GSE_GO, n_plots = 12)
p12

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/GO/RunningScore_top12.png",  # Specify the file path and name
  plot = p12,  # The plot to save
  width = 14, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

#### Top 24 running score plot 


```{r fig.width=14, fig.height=18}
# Display top 24 pathways
p24 <- plot_gsea_results(GSE_GO, n_plots = 24)
p24

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/GO/RunningScore_top24.png",  # Specify the file path and name
  plot = p24,  # The plot to save
  width = 14, height = 18,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```



## Pathway specific plots


#### Electron Transfer Activity


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "GOMF_ELECTRON_TRANSFER_ACTIVITY",
  gsea_results = GSE_GO,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05, 
  p_method = "P.Value",
  fc_cutoff = 4.0,
  label_method = "p",  # or "fc"
  max_overlaps = 60, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)


print(p)

ggsave(
  filename = "imgs/volcano/GO/Electron_transfer.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "GOMF_ELECTRON_TRANSFER_ACTIVITY",
  gsea_results = GSE_GO,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 4.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/GO/Electron_transfer.html")
```

#### WNT Receptor Activity


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "GOMF_WNT_ACTIVATED_RECEPTOR_ACTIVITY",
  gsea_results = GSE_GO,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05, 
  p_method = "P.Value",
  fc_cutoff = 4.0,
  label_method = "p",  # or "fc"
  max_overlaps = 60, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)


print(p)

ggsave(
  filename = "imgs/volcano/GO/WNT.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "GOMF_WNT_ACTIVATED_RECEPTOR_ACTIVITY",
  gsea_results = GSE_GO,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 4.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/GO/WNT.html")
```

<hr />

## 4.3 MSigDB C2 Canonical Pathways (CP) gene sets enrichment analysis


```{r echo = FALSE}
library(org.Mm.eg.db)  # Mouse-specific annotation
library(msigdbr) # MSigDB
library(clusterProfiler)

# Prepare the ranked gene list (from limma results)
# Rank by logFC or another relevant statistic


# Retrieve C2 gene sets from MSigDB
msigdb_C2CP <- msigdbr(species = "Mus musculus", 
                     category = "C2",
                     subcategory = "CP")

# Perform GSEA using clusterProfiler
GSE_C2CP <- GSEA(ranked_genes, 
                     TERM2GENE = msigdb_C2CP[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0, # p value is not 
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```

### All C2CP Pathways


```{r fig.width=10, fig.height=14}
p <- custom_dotplot(gsea_obj = GSE_C2CP, 
               showCategory = 100, 
               font.size = 10, 
               title = "MECR-KO GSEA C2 curated pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_C2CP)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold-0.01, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/GSEA_C2CP_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```



### Top 20 C2CP Pathways


```{r fig.width=10, fig.height=8}
p <- custom_dotplot(gsea_obj = GSE_C2CP, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA C2 curated pathways pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/GSEA_C2CP_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Running score plots 

```{r}
library(enrichplot)
```



#### Top 5 Pathways running score plot 


```{r}
p <- gseaplot2(GSE_C2CP, geneSetID = 1:5)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/RunningScore_top5.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


```{r fig.width=14, fig.height=8, include = FALSE}
# Display the top 12 pathways:
p12 <- plot_gsea_results(GSE_C2CP, n_plots = 12)
p12
# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/RunningScore_top12.png",  # Specify the file path and name
  plot = p12,  # The plot to save
  width = 14, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```



#### Top 24 running score plot 


```{r fig.width=14, fig.height=18}
# Display top 24 pathways
p24 <- plot_gsea_results(GSE_C2CP, n_plots = 24)
p24

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/C2_CP/RunningScore_top24.png",  # Specify the file path and name
  plot = p24,  # The plot to save
  width = 14, height = 18,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

<hr />

## 4.4 KEGG pathways enrichment analysis


```{r echo = FALSE}
# library(clusterProfiler)
# 
# #search_kegg_organism('mmu', by='kegg_code')
# 
# #### Gene KeyType conversion
# 
# # 1. Loading the ranked gene list, by t
# ranked_genes <- DE_KOvsWT$t
# names(ranked_genes) <- rownames(DE_KOvsWT)  # Ensure the 'Gene' column contains symbols
# # 1.2. Sort the vector to be decreasing
# ranked_genes <- sort(ranked_genes, decreasing = TRUE)
# 
# # 2. Convert gene symbols to Entrez IDs (for human genes, replace `org.Hs.eg.db` as necessary)
# ids <- bitr(names(ranked_genes), 
#             fromType = "SYMBOL", 
#             toType = "ENTREZID", 
#             OrgDb = org.Mm.eg.db)
# 
# # 3. Remove duplicates (keep unique Entrez IDs)
# dedup_ids <- ids[!duplicated(ids$ENTREZID),]
# 
# # 4. Match and filter gene list to include only the mapped genes
# ranked_genes_mapped <- ranked_genes[names(ranked_genes) %in% dedup_ids$SYMBOL]
# names(ranked_genes_mapped) <- dedup_ids$ENTREZID[match(names(ranked_genes_mapped), dedup_ids$SYMBOL)]
# 
# # 5. Sort the vector to be decreasing
# ranked_genes_mapped <- sort(ranked_genes_mapped, decreasing = TRUE)
```

```{r echo = FALSE}
# Retrieve C2 gene sets from MSigDB
msigdb_KEGG <- msigdbr(species = "Mus musculus", 
                     category = "C2",
                     subcategory = "KEGG")

# Perform GSEA using clusterProfiler
GSE_msigKEGG <- GSEA(ranked_genes, 
                     TERM2GENE = msigdb_KEGG[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0, # p value is not 
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```

### All KEGG Pathways
```{r fig.width=10, fig.height=14}
p <- custom_dotplot(gsea_obj = GSE_msigKEGG, 
               showCategory = 100, 
               font.size = 10, 
               title = "MECR-KO GSEA C2 curated pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_msigKEGG)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/GSEA_KEGG_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 14,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```



### Top 20 KEGG Pathways


```{r fig.width=10, fig.height=8}
p <- custom_dotplot(gsea_obj = GSE_msigKEGG, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA KEGG pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/GSEA_KEGG_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

So far as we are not interested in particular disease related pathways or cancer types, while KEGG is abandunt in those, I have tried to manually filter pathways, that contain keywords, such as `cancer`, `disease`, `leukemia`,`carcinoma`, `depression`, `lupus`, `infection`,  and other *`oma`s (like melanoma, carcinoma etc.)

```{r echo = FALSE}
library(dplyr)
library(stringr)

# List of disease-related keywords to filter out
disease_keywords <- c("cancer", "disease", "leukemia", 
                      "carcinoma", "depression", "infection",
                      "lupus")

# Filter out pathways with disease-related keywords or ending in "*oma"
filtered_KEGG <- msigdb_KEGG %>%
  mutate(gs_name_lower = str_to_lower(gs_name),      # Convert to lowercase for case-insensitive matching
         gs_name_clean = str_replace_all(gs_name_lower, "_", " ")) %>%   # Replace "_" with space
  filter(
    !str_detect(gs_name_clean, paste(disease_keywords, collapse = "|")) &  # Exclude if contains any of the disease keywords
    !str_detect(str_extract(gs_name_clean, "\\w+$"), "oma$")               # Exclude if the last word ends with "oma"
  )

# Drop the temporary columns used for filtering
filtered_KEGG <- filtered_KEGG %>%
  select(-gs_name_lower, -gs_name_clean)
```


```{r echo = FALSE}
# Perform GSEA using clusterProfiler
GSE_msigKEGG_no_disease <- GSEA(ranked_genes, 
                     TERM2GENE = filtered_KEGG[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 1, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0, # p value is not 
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```



### All KEGG (no disease) Pathways


```{r fig.width=10, fig.height=14}
p <- custom_dotplot(gsea_obj = GSE_msigKEGG_no_disease, 
               showCategory = 100, 
               font.size = 10, 
               title = "MECR-KO GSEA KEGG pathways (no disease), qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_msigKEGG_no_disease)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/GSEA_KEGG_no_disease_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 14,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


### Top 20 KEGG (no disese) Pathways


```{r fig.width=10, fig.height=8}
p <- custom_dotplot(gsea_obj = GSE_msigKEGG_no_disease, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA KEGG (no disease) pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/GSEA_KEGG_no_disease_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

### Running score plots 

#### Top 5 Pathways running score plot 
```{r}
p <- gseaplot2(GSE_msigKEGG_no_disease, geneSetID = 1:5)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/RunningScore_top5.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


```{r fig.width=14, fig.height=8, include = FALSE}
# Display the top 12 pathways:
p12 <- plot_gsea_results(GSE_msigKEGG_no_disease, n_plots = 12)
p12
# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/RunningScore_top12.png",  # Specify the file path and name
  plot = p12,  # The plot to save
  width = 14, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


#### Top 24 running score plot 

```{r fig.width=14, fig.height=18}
# Display top 24 pathways
p24 <- plot_gsea_results(GSE_msigKEGG_no_disease, n_plots = 24)
p24

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/RunningScore_top24.png",  # Specify the file path and name
  plot = p24,  # The plot to save
  width = 14, height = 18,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


### Pathway-specific Plots

#### Antigen Processing & Presentation


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "all",  # or "fc"
  max_overlaps = 20, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/KEGG/AG_presentation.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```
```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "KEGG_ANTIGEN_PROCESSING_AND_PRESENTATION",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/KEGG/AGprocessing.html")
```



#### AG processing running score plot 


```{r}
title = "KEGG ANTIGEN PROCESSING AND PRESENTATION"

p <- gseaplot(GSE_msigKEGG_no_disease, 
              geneSetID = 20, 
              by = "runningScore", 
              title = title)
p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/KEGG/RunningScore_AgProcessing.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 5,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```

#### TCR signaling 


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "KEGG_T_CELL_RECEPTOR_SIGNALING_PATHWAY",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "all",  # or "fc"
  max_overlaps = 25, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/KEGG/TCR_signaling.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "KEGG_T_CELL_RECEPTOR_SIGNALING_PATHWAY",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/KEGG/TCR.html")
```


#### Citrate cycle TCA


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "KEGG_CITRATE_CYCLE_TCA_CYCLE",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "all",  # or "fc"
  max_overlaps = 40, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/KEGG/TCA.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```
```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "KEGG_CITRATE_CYCLE_TCA_CYCLE",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/KEGG/TCA.html")
```

#### Glycolysis


```{r include = FALSE}
p <- analyze_pathway_volcano(
  pathway_name = "KEGG_GLYCOLYSIS_GLUCONEOGENESIS",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "all",  # or "fc"
  max_overlaps = 20, 
  style = "clean",
  x_breaks = 5
) 

p <- p +
  xlim(-22,15)

print(p)

ggsave(
  filename = "imgs/volcano/KEGG/Glycolysis.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 8, height = 6,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```
```{r}
# Generate an interactive volcano plot
interactive_plot <- analyze_pathway_volcano_interactive(
  pathway_name = "KEGG_GLYCOLYSIS_GLUCONEOGENESIS",
  gsea_results = GSE_msigKEGG_no_disease,
  de_results = DE_KOvsWT,
  p_cutoff = 0.05,
  fc_cutoff = 2.0,
  label_method = "default",
  max_overlaps = 50,
  style = 'clean',
  x_breaks = 2  # Set x-axis breaks to every 2 logFC units
)

# Convert to an interactive plot using plotly with specific dimensions
interactive_plot <- interactive_plot %>%
  layout(width = interactive_width, height = interactive_height)  # Set the width and height to your desired dimensions

interactive_plot

# Save the interactive plot as an HTML file
htmlwidgets::saveWidget(interactive_plot, "imgs/volcano/KEGG/Glycolysis.html")
```

<hr />

## 4.5 REACTOME Pathways enrichment analysis


```{r}
library(clusterProfiler)
library(ReactomePA)

# 1. Loading the ranked gene list, by t-statistic
ranked_genes <- DE_KOvsWT$t
names(ranked_genes) <- rownames(DE_KOvsWT)  # Ensure the 'Gene' column contains symbols
# 1.2. Sort the vector to be decreasing
ranked_genes <- sort(ranked_genes, decreasing = TRUE)

# 2. Convert gene symbols to Entrez IDs (for human genes, replace `org.Hs.eg.db` as necessary)
ids <- bitr(names(ranked_genes), 
            fromType = "SYMBOL", 
            toType = "ENTREZID", 
            OrgDb = org.Mm.eg.db)

# 3. Remove duplicates (keep unique Entrez IDs)
dedup_ids <- ids[!duplicated(ids$ENTREZID),]

# 4. Match and filter gene list to include only the mapped genes
ranked_genes_mapped <- ranked_genes[names(ranked_genes) %in% dedup_ids$SYMBOL]
names(ranked_genes_mapped) <- dedup_ids$ENTREZID[match(names(ranked_genes_mapped), dedup_ids$SYMBOL)]

# 5. Sort the vector to be decreasing
ranked_genes_mapped <- sort(ranked_genes_mapped, decreasing = TRUE)

# 6. Run Reactome GSEA
GSE_Reactome <- gsePathway(ranked_genes_mapped, 
                organism = "mouse",
                pvalueCutoff = 1,
                pAdjustMethod = "fdr", 
                by = "fgsea",
                verbose = FALSE,
                eps = 0,
                seed = 123,
                nPermSimple = 100000)
```



### All REACTOME Pathways


```{r fig.width=10, fig.height=14}
p <- custom_dotplot(gsea_obj = GSE_Reactome, 
               showCategory = 100, 
               font.size = 10, 
               title = "MECR-KO GSEA C2 curated pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 1,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

# Extract the data used for plotting
gsea_data <- as.data.frame(GSE_Reactome)

# Calculate GeneRatio and filter for qvalue < 0.05
gsea_data <- gsea_data %>%
  group_by(ID) %>%
  summarise(count = sum(str_count(core_enrichment, "/")) + 1) %>%
  left_join(gsea_data, by = "ID") %>%
  mutate(GeneRatio = count / setSize) %>%
  filter(qvalue < 0.05)  # Apply the qvalue filter

# Find the minimum GeneRatio corresponding to qvalue < 0.05
gene_ratio_threshold <- min(gsea_data$GeneRatio)

# Add a vertical dashed line and label at this GeneRatio
p <- p + 
  geom_vline(xintercept = gene_ratio_threshold, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = gene_ratio_threshold, y = Inf, label = "qvalue = 0.05 threshold",
           hjust = -0.1, vjust = 1.5, color = "red", size = 4, angle = 0)

p

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/REACTOME/GSEA_Reactome_all.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 14,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


### Top 20 KEGG Pathways


```{r fig.width=10, fig.height=8}
p <- custom_dotplot(gsea_obj = GSE_Reactome, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA REACTOME pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/REACTOME/GSEA_Reactome_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```


<hr />

## 4.6 IMMUNESIGDB Pathways enrichment analysis

Here is the list of the enriched Hallmark Pathways.

ImmuneSigDB subset of C7

```{r echo = FALSE}
library(org.Mm.eg.db)  # Mouse-specific annotation
library(msigdbr) # MSigDB
library(clusterProfiler)


# Prepare the ranked gene list (from limma results)
# Rank by logFC or another relevant statistic

# Rank by t.value
ranked_genes <- DE_KOvsWT$t
names(ranked_genes) <- rownames(DE_KOvsWT) # Ensure Gene column contains gene symbols

# Sort genes by t (or other ranking criterion), just in case it hasn`t been sorted already
ranked_genes <- sort(ranked_genes, decreasing = TRUE)

# Retrieve Mouse C5 gene sets from MSigDB
msigdb_C7 <- msigdbr(species = "Mus musculus", category = "C7")  # "C7" 

# Filter for IMMUNESIGDB gene sets
immunesigdb_C7 <- msigdb_C7[msigdb_C7$gs_subcat == "IMMUNESIGDB",]

# Perform GSEA using clusterProfiler
immunesig_results <- GSEA(ranked_genes, 
                     TERM2GENE = immunesigdb_C7[, c("gs_name", "gene_symbol")], 
                     pvalueCutoff = 0.05, 
                     verbose = FALSE,
                     pAdjustMethod = "fdr",
                     eps = 0,
                     by = "fgsea",
                     seed = 123,
                     nPermSimple = 100000)
```


### Top 20 IMMUNESIGDB Pathways


```{r fig.width=10, fig.height=8}
p <- custom_dotplot(gsea_obj = immunesig_results, 
               showCategory = 20, 
               font.size = 10, 
               title = "Top MECR-KO GSEA enriched IMMUNESIGDB pathways, qvalue < 0.05",
               sortBy = "GeneRatio", 
               filterBy = "NES", 
               q_cut = 0.05,
               replace_ = TRUE, 
               capitalize_1 = FALSE,
               capitalize_all = FALSE 
               )

print(p)

# Save the plot to disk using ggsave()
ggsave(
  filename = "imgs/GSEA/GSEA_immunesig_top.png",  # Specify the file path and name
  plot = p,  # The plot to save
  width = 10, height = 8,  # Dimensions of the image in inches
  dpi = 300  # Resolution of the image
)
```







